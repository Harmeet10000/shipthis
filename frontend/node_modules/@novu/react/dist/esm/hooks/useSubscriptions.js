// src/hooks/useSubscriptions.ts
import { useCallback, useEffect, useState } from "react";
import { useNovu } from "./NovuProvider.js";
var useSubscriptions = ({ topicKey, onSuccess, onError }) => {
  const novu = useNovu();
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [isLoading, setIsLoading] = useState(true);
  const [isFetching, setIsFetching] = useState(false);
  const fetchSubscriptions = useCallback(
    async (options) => {
      if (options?.refetch) {
        setError(void 0);
        setIsLoading(true);
        novu.subscriptions.cache.invalidate({ topicKey });
      }
      setIsFetching(true);
      const response = await novu.subscriptions.list({ topicKey }, { refetch: options?.refetch });
      if (response.error) {
        setError(response.error);
        onError?.(response.error);
      } else if (response.data) {
        onSuccess?.(response.data);
        setData(response.data);
      }
      setIsLoading(false);
      setIsFetching(false);
    },
    [novu, topicKey, onError, onSuccess]
  );
  useEffect(() => {
    const cleanupListPending = novu.on("subscriptions.list.pending", ({ args }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupListResolved = novu.on("subscriptions.list.resolved", ({ args, data: data2, error: error2 }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      if (error2) {
        setError(error2);
        onError?.(error2);
      } else if (data2) {
        onSuccess?.(data2);
        setData(data2);
      }
      setIsLoading(false);
      setIsFetching(false);
    });
    const cleanupListUpdated = novu.on("subscriptions.list.updated", ({ data: data2 }) => {
      if (data2.topicKey !== topicKey) {
        return;
      }
      setData(data2.subscriptions);
    });
    const cleanupCreateResolved = novu.on("subscription.create.resolved", ({ args, data: data2 }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      if (data2) {
        void fetchSubscriptions({ refetch: true });
      }
    });
    const cleanupDeleteResolved = novu.on("subscription.delete.resolved", ({ args }) => {
      const deleteTopicKey = "subscription" in args ? args.subscription.topicKey : topicKey;
      if (deleteTopicKey !== topicKey) {
        return;
      }
      void fetchSubscriptions({ refetch: true });
    });
    void fetchSubscriptions({ refetch: true });
    return () => {
      cleanupListPending();
      cleanupListResolved();
      cleanupListUpdated();
      cleanupCreateResolved();
      cleanupDeleteResolved();
    };
  }, [topicKey, novu, fetchSubscriptions, onError, onSuccess]);
  const refetch = useCallback(() => {
    return fetchSubscriptions({ refetch: true });
  }, [fetchSubscriptions]);
  return {
    subscriptions: data,
    error,
    isLoading,
    isFetching,
    refetch
  };
};
export {
  useSubscriptions
};
//# sourceMappingURL=useSubscriptions.js.map