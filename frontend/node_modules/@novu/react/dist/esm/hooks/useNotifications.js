// src/hooks/useNotifications.ts
import { checkNotificationMatchesFilter, isSameFilter } from "@novu/js";
import { useCallback, useEffect, useState } from "react";
import { useDataRef } from "./internal/useDataRef.js";
import { useWebSocketEvent } from "./internal/useWebsocketEvent.js";
import { useNovu } from "./NovuProvider.js";
var useNotifications = (props) => {
  const {
    tags,
    data: dataFilter,
    read,
    archived = false,
    snoozed = false,
    seen,
    severity,
    limit = 10,
    onSuccess,
    onError
  } = props || {};
  const limitRef = useDataRef(limit);
  const filterRef = useDataRef({ tags, data: dataFilter, read, archived, snoozed, seen, severity });
  const novu = useNovu();
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [isLoading, setIsLoading] = useState(true);
  const [isFetching, setIsFetching] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const length = data?.length;
  const after = length ? data[length - 1].id : void 0;
  const afterRef = useDataRef(after);
  useEffect(() => {
    const listener = ({
      data: data2
    }) => {
      if (!data2 || !isSameFilter(filterRef.current, data2.filter)) {
        return;
      }
      setData(data2.notifications);
      setHasMore(data2.hasMore);
    };
    const cleanup = novu.on("notifications.list.updated", listener);
    return () => {
      cleanup();
    };
  }, [filterRef, novu]);
  useWebSocketEvent({
    event: "notifications.notification_received",
    eventHandler: ({ result: notification }) => {
      const currentFilter = filterRef.current;
      const matches = checkNotificationMatchesFilter(notification, currentFilter);
      if (matches) {
        const cacheKey = { ...currentFilter, limit: limitRef.current };
        novu.notifications.cache.unshift(cacheKey, notification);
      }
    }
  });
  const fetchNotifications = useCallback(
    async (options) => {
      if (options?.refetch) {
        setError(void 0);
        setIsLoading(true);
        setIsFetching(false);
      }
      setIsFetching(true);
      const response = await novu.notifications.list({
        ...filterRef.current,
        limit,
        after: options?.refetch ? void 0 : afterRef.current
      });
      if (response.error) {
        setError(response.error);
        onError?.(response.error);
        setIsLoading(false);
        setIsFetching(false);
      } else if (response.data) {
        const responseData = response.data;
        onSuccess?.(responseData.notifications);
        setData(responseData.notifications);
        setHasMore(responseData.hasMore);
        setIsLoading(false);
        setIsFetching(false);
      }
    },
    [novu, filterRef, afterRef, limit, onError, onSuccess]
  );
  useEffect(() => {
    novu.notifications.clearCache({ filter: filterRef.current });
    fetchNotifications({ refetch: true });
  }, [filterRef, novu, JSON.stringify(filterRef.current), fetchNotifications]);
  const refetch = useCallback(() => {
    novu.notifications.clearCache({ filter: filterRef.current });
    return fetchNotifications({ refetch: true });
  }, [filterRef, novu, fetchNotifications]);
  const fetchMore = useCallback(async () => {
    if (!hasMore || isFetching) return;
    return fetchNotifications();
  }, [hasMore, isFetching, fetchNotifications]);
  const readAll = useCallback(async () => {
    return await novu.notifications.readAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const seenAll = useCallback(async () => {
    return await novu.notifications.seenAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const archiveAll = useCallback(async () => {
    return await novu.notifications.archiveAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const archiveAllRead = useCallback(async () => {
    return await novu.notifications.archiveAllRead({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  return {
    readAll,
    seenAll,
    archiveAll,
    archiveAllRead,
    notifications: data,
    error,
    isLoading,
    isFetching,
    refetch,
    fetchMore,
    hasMore
  };
};
export {
  useNotifications
};
//# sourceMappingURL=useNotifications.js.map