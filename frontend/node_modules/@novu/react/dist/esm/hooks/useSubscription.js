// src/hooks/useSubscription.ts
import { buildSubscriptionIdentifier } from "@novu/js/internal";
import { useCallback, useEffect, useRef, useState } from "react";
import { useNovu } from "./NovuProvider.js";
var useSubscription = (props) => {
  const novu = useNovu();
  const propsRef = useRef(props);
  propsRef.current = {
    ...props,
    identifier: props.identifier ?? buildSubscriptionIdentifier({ topicKey: props.topicKey, subscriberId: novu.subscriberId })
  };
  const [subscription, setSubscription] = useState();
  const subscriptionRef = useRef(null);
  subscriptionRef.current = subscription ?? null;
  const [error, setError] = useState();
  const [isLoading, setIsLoading] = useState(true);
  const [isFetching, setIsFetching] = useState(false);
  const fetchSubscription = useCallback(
    async (options) => {
      const { topicKey, identifier, onSuccess, onError } = propsRef.current;
      if (options?.refetch) {
        setError(void 0);
        setIsLoading(true);
      }
      setIsFetching(true);
      const response = await novu.subscriptions.get(
        {
          topicKey,
          identifier
        },
        { refetch: options?.refetch }
      );
      if (response.error) {
        setError(response.error);
        onError?.(response.error);
      } else if (response.data !== void 0) {
        onSuccess?.(response.data);
        setSubscription(response.data);
      }
      setIsLoading(false);
      setIsFetching(false);
    },
    [novu]
  );
  useEffect(() => {
    const listener = ({ data: subscription2 }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!subscription2 || subscription2.topicKey !== topicKey || subscription2.identifier !== identifier) {
        return;
      }
      setSubscription(subscription2);
      setIsFetching(false);
    };
    const cleanupGetPending = novu.on("subscription.get.pending", ({ args }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupGetResolved = novu.on("subscription.get.resolved", ({ args, data, error: error2 }) => {
      const { topicKey, identifier, onSuccess, onError } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      if (error2) {
        setError(error2);
        onError?.(error2);
      } else {
        setSubscription(data ?? null);
        onSuccess?.(data ?? null);
      }
      setIsFetching(false);
    });
    const cleanupCreatePending = novu.on("subscription.create.pending", ({ args }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupCreateResolved = novu.on("subscription.create.resolved", listener);
    const cleanupUpdateResolved = novu.on("subscription.update.resolved", listener);
    const cleanupDeletePending = novu.on("subscription.delete.pending", ({ args }) => {
      const subscriptionId = subscriptionRef.current?.id;
      const subscriptionIdentifier = subscriptionRef.current?.identifier;
      if (!subscriptionId || !subscriptionIdentifier) {
        return;
      }
      if (!args || "subscriptionId" in args && args.subscriptionId !== subscriptionId && args.subscriptionId !== subscriptionIdentifier || "subscription" in args && args.subscription.id !== subscriptionId && args.subscription.identifier !== subscriptionIdentifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupDeleteResolved = novu.on("subscription.delete.resolved", ({ args }) => {
      const subscriptionId = subscriptionRef.current?.id;
      const subscriptionIdentifier = subscriptionRef.current?.identifier;
      if (!subscriptionId || !subscriptionIdentifier) {
        return;
      }
      if ("subscriptionId" in args && args.subscriptionId === subscriptionId || "subscriptionId" in args && args.subscriptionId === subscriptionIdentifier || "subscription" in args && args.subscription.id === subscriptionId || "subscription" in args && args.subscription.identifier === subscriptionIdentifier) {
        setSubscription(null);
        setIsFetching(false);
      }
    });
    void fetchSubscription({ refetch: true });
    return () => {
      cleanupGetPending();
      cleanupGetResolved();
      cleanupCreatePending();
      cleanupCreateResolved();
      cleanupUpdateResolved();
      cleanupDeletePending();
      cleanupDeleteResolved();
    };
  }, [novu, fetchSubscription]);
  const refetch = useCallback(() => fetchSubscription({ refetch: true }), [fetchSubscription]);
  return {
    subscription,
    error,
    isLoading,
    isFetching,
    refetch
  };
};
export {
  useSubscription
};
//# sourceMappingURL=useSubscription.js.map