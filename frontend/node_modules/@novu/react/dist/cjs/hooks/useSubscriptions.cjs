"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hooks/useSubscriptions.ts
var useSubscriptions_exports = {};
__export(useSubscriptions_exports, {
  useSubscriptions: () => useSubscriptions
});
module.exports = __toCommonJS(useSubscriptions_exports);
var import_react = require("react");
var import_NovuProvider = require("./NovuProvider.cjs");
var useSubscriptions = ({ topicKey, onSuccess, onError }) => {
  const novu = (0, import_NovuProvider.useNovu)();
  const [data, setData] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)();
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [isFetching, setIsFetching] = (0, import_react.useState)(false);
  const fetchSubscriptions = (0, import_react.useCallback)(
    async (options) => {
      if (options == null ? void 0 : options.refetch) {
        setError(void 0);
        setIsLoading(true);
        novu.subscriptions.cache.invalidate({ topicKey });
      }
      setIsFetching(true);
      const response = await novu.subscriptions.list({ topicKey }, { refetch: options == null ? void 0 : options.refetch });
      if (response.error) {
        setError(response.error);
        onError == null ? void 0 : onError(response.error);
      } else if (response.data) {
        onSuccess == null ? void 0 : onSuccess(response.data);
        setData(response.data);
      }
      setIsLoading(false);
      setIsFetching(false);
    },
    [novu, topicKey, onError, onSuccess]
  );
  (0, import_react.useEffect)(() => {
    const cleanupListPending = novu.on("subscriptions.list.pending", ({ args }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupListResolved = novu.on("subscriptions.list.resolved", ({ args, data: data2, error: error2 }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      if (error2) {
        setError(error2);
        onError == null ? void 0 : onError(error2);
      } else if (data2) {
        onSuccess == null ? void 0 : onSuccess(data2);
        setData(data2);
      }
      setIsLoading(false);
      setIsFetching(false);
    });
    const cleanupListUpdated = novu.on("subscriptions.list.updated", ({ data: data2 }) => {
      if (data2.topicKey !== topicKey) {
        return;
      }
      setData(data2.subscriptions);
    });
    const cleanupCreateResolved = novu.on("subscription.create.resolved", ({ args, data: data2 }) => {
      if (args.topicKey !== topicKey) {
        return;
      }
      if (data2) {
        void fetchSubscriptions({ refetch: true });
      }
    });
    const cleanupDeleteResolved = novu.on("subscription.delete.resolved", ({ args }) => {
      const deleteTopicKey = "subscription" in args ? args.subscription.topicKey : topicKey;
      if (deleteTopicKey !== topicKey) {
        return;
      }
      void fetchSubscriptions({ refetch: true });
    });
    void fetchSubscriptions({ refetch: true });
    return () => {
      cleanupListPending();
      cleanupListResolved();
      cleanupListUpdated();
      cleanupCreateResolved();
      cleanupDeleteResolved();
    };
  }, [topicKey, novu, fetchSubscriptions, onError, onSuccess]);
  const refetch = (0, import_react.useCallback)(() => {
    return fetchSubscriptions({ refetch: true });
  }, [fetchSubscriptions]);
  return {
    subscriptions: data,
    error,
    isLoading,
    isFetching,
    refetch
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useSubscriptions
});
//# sourceMappingURL=useSubscriptions.cjs.map