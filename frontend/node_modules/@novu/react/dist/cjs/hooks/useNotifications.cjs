"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hooks/useNotifications.ts
var useNotifications_exports = {};
__export(useNotifications_exports, {
  useNotifications: () => useNotifications
});
module.exports = __toCommonJS(useNotifications_exports);
var import_js = require("@novu/js");
var import_react = require("react");
var import_useDataRef = require("./internal/useDataRef.cjs");
var import_useWebsocketEvent = require("./internal/useWebsocketEvent.cjs");
var import_NovuProvider = require("./NovuProvider.cjs");
var useNotifications = (props) => {
  const {
    tags,
    data: dataFilter,
    read,
    archived = false,
    snoozed = false,
    seen,
    severity,
    limit = 10,
    onSuccess,
    onError
  } = props || {};
  const limitRef = (0, import_useDataRef.useDataRef)(limit);
  const filterRef = (0, import_useDataRef.useDataRef)({ tags, data: dataFilter, read, archived, snoozed, seen, severity });
  const novu = (0, import_NovuProvider.useNovu)();
  const [data, setData] = (0, import_react.useState)();
  const [error, setError] = (0, import_react.useState)();
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [isFetching, setIsFetching] = (0, import_react.useState)(false);
  const [hasMore, setHasMore] = (0, import_react.useState)(false);
  const length = data == null ? void 0 : data.length;
  const after = length ? data[length - 1].id : void 0;
  const afterRef = (0, import_useDataRef.useDataRef)(after);
  (0, import_react.useEffect)(() => {
    const listener = ({
      data: data2
    }) => {
      if (!data2 || !(0, import_js.isSameFilter)(filterRef.current, data2.filter)) {
        return;
      }
      setData(data2.notifications);
      setHasMore(data2.hasMore);
    };
    const cleanup = novu.on("notifications.list.updated", listener);
    return () => {
      cleanup();
    };
  }, [filterRef, novu]);
  (0, import_useWebsocketEvent.useWebSocketEvent)({
    event: "notifications.notification_received",
    eventHandler: ({ result: notification }) => {
      const currentFilter = filterRef.current;
      const matches = (0, import_js.checkNotificationMatchesFilter)(notification, currentFilter);
      if (matches) {
        const cacheKey = { ...currentFilter, limit: limitRef.current };
        novu.notifications.cache.unshift(cacheKey, notification);
      }
    }
  });
  const fetchNotifications = (0, import_react.useCallback)(
    async (options) => {
      if (options == null ? void 0 : options.refetch) {
        setError(void 0);
        setIsLoading(true);
        setIsFetching(false);
      }
      setIsFetching(true);
      const response = await novu.notifications.list({
        ...filterRef.current,
        limit,
        after: (options == null ? void 0 : options.refetch) ? void 0 : afterRef.current
      });
      if (response.error) {
        setError(response.error);
        onError == null ? void 0 : onError(response.error);
        setIsLoading(false);
        setIsFetching(false);
      } else if (response.data) {
        const responseData = response.data;
        onSuccess == null ? void 0 : onSuccess(responseData.notifications);
        setData(responseData.notifications);
        setHasMore(responseData.hasMore);
        setIsLoading(false);
        setIsFetching(false);
      }
    },
    [novu, filterRef, afterRef, limit, onError, onSuccess]
  );
  (0, import_react.useEffect)(() => {
    novu.notifications.clearCache({ filter: filterRef.current });
    fetchNotifications({ refetch: true });
  }, [filterRef, novu, JSON.stringify(filterRef.current), fetchNotifications]);
  const refetch = (0, import_react.useCallback)(() => {
    novu.notifications.clearCache({ filter: filterRef.current });
    return fetchNotifications({ refetch: true });
  }, [filterRef, novu, fetchNotifications]);
  const fetchMore = (0, import_react.useCallback)(async () => {
    if (!hasMore || isFetching) return;
    return fetchNotifications();
  }, [hasMore, isFetching, fetchNotifications]);
  const readAll = (0, import_react.useCallback)(async () => {
    return await novu.notifications.readAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const seenAll = (0, import_react.useCallback)(async () => {
    return await novu.notifications.seenAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const archiveAll = (0, import_react.useCallback)(async () => {
    return await novu.notifications.archiveAll({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  const archiveAllRead = (0, import_react.useCallback)(async () => {
    return await novu.notifications.archiveAllRead({ tags: filterRef.current.tags, data: filterRef.current.data });
  }, [filterRef, novu]);
  return {
    readAll,
    seenAll,
    archiveAll,
    archiveAllRead,
    notifications: data,
    error,
    isLoading,
    isFetching,
    refetch,
    fetchMore,
    hasMore
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useNotifications
});
//# sourceMappingURL=useNotifications.cjs.map