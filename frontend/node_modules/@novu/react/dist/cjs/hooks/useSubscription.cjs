"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/hooks/useSubscription.ts
var useSubscription_exports = {};
__export(useSubscription_exports, {
  useSubscription: () => useSubscription
});
module.exports = __toCommonJS(useSubscription_exports);
var import_internal = require("@novu/js/internal");
var import_react = require("react");
var import_NovuProvider = require("./NovuProvider.cjs");
var useSubscription = (props) => {
  const novu = (0, import_NovuProvider.useNovu)();
  const propsRef = (0, import_react.useRef)(props);
  propsRef.current = {
    ...props,
    identifier: props.identifier ?? (0, import_internal.buildSubscriptionIdentifier)({ topicKey: props.topicKey, subscriberId: novu.subscriberId })
  };
  const [subscription, setSubscription] = (0, import_react.useState)();
  const subscriptionRef = (0, import_react.useRef)(null);
  subscriptionRef.current = subscription ?? null;
  const [error, setError] = (0, import_react.useState)();
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [isFetching, setIsFetching] = (0, import_react.useState)(false);
  const fetchSubscription = (0, import_react.useCallback)(
    async (options) => {
      const { topicKey, identifier, onSuccess, onError } = propsRef.current;
      if (options == null ? void 0 : options.refetch) {
        setError(void 0);
        setIsLoading(true);
      }
      setIsFetching(true);
      const response = await novu.subscriptions.get(
        {
          topicKey,
          identifier
        },
        { refetch: options == null ? void 0 : options.refetch }
      );
      if (response.error) {
        setError(response.error);
        onError == null ? void 0 : onError(response.error);
      } else if (response.data !== void 0) {
        onSuccess == null ? void 0 : onSuccess(response.data);
        setSubscription(response.data);
      }
      setIsLoading(false);
      setIsFetching(false);
    },
    [novu]
  );
  (0, import_react.useEffect)(() => {
    const listener = ({ data: subscription2 }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!subscription2 || subscription2.topicKey !== topicKey || subscription2.identifier !== identifier) {
        return;
      }
      setSubscription(subscription2);
      setIsFetching(false);
    };
    const cleanupGetPending = novu.on("subscription.get.pending", ({ args }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupGetResolved = novu.on("subscription.get.resolved", ({ args, data, error: error2 }) => {
      const { topicKey, identifier, onSuccess, onError } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      if (error2) {
        setError(error2);
        onError == null ? void 0 : onError(error2);
      } else {
        setSubscription(data ?? null);
        onSuccess == null ? void 0 : onSuccess(data ?? null);
      }
      setIsFetching(false);
    });
    const cleanupCreatePending = novu.on("subscription.create.pending", ({ args }) => {
      const { topicKey, identifier } = propsRef.current;
      if (!args || args.topicKey !== topicKey || args.identifier !== identifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupCreateResolved = novu.on("subscription.create.resolved", listener);
    const cleanupUpdateResolved = novu.on("subscription.update.resolved", listener);
    const cleanupDeletePending = novu.on("subscription.delete.pending", ({ args }) => {
      var _a, _b;
      const subscriptionId = (_a = subscriptionRef.current) == null ? void 0 : _a.id;
      const subscriptionIdentifier = (_b = subscriptionRef.current) == null ? void 0 : _b.identifier;
      if (!subscriptionId || !subscriptionIdentifier) {
        return;
      }
      if (!args || "subscriptionId" in args && args.subscriptionId !== subscriptionId && args.subscriptionId !== subscriptionIdentifier || "subscription" in args && args.subscription.id !== subscriptionId && args.subscription.identifier !== subscriptionIdentifier) {
        return;
      }
      setIsFetching(true);
    });
    const cleanupDeleteResolved = novu.on("subscription.delete.resolved", ({ args }) => {
      var _a, _b;
      const subscriptionId = (_a = subscriptionRef.current) == null ? void 0 : _a.id;
      const subscriptionIdentifier = (_b = subscriptionRef.current) == null ? void 0 : _b.identifier;
      if (!subscriptionId || !subscriptionIdentifier) {
        return;
      }
      if ("subscriptionId" in args && args.subscriptionId === subscriptionId || "subscriptionId" in args && args.subscriptionId === subscriptionIdentifier || "subscription" in args && args.subscription.id === subscriptionId || "subscription" in args && args.subscription.identifier === subscriptionIdentifier) {
        setSubscription(null);
        setIsFetching(false);
      }
    });
    void fetchSubscription({ refetch: true });
    return () => {
      cleanupGetPending();
      cleanupGetResolved();
      cleanupCreatePending();
      cleanupCreateResolved();
      cleanupUpdateResolved();
      cleanupDeletePending();
      cleanupDeleteResolved();
    };
  }, [novu, fetchSubscription]);
  const refetch = (0, import_react.useCallback)(() => fetchSubscription({ refetch: true }), [fetchSubscription]);
  return {
    subscription,
    error,
    isLoading,
    isFetching,
    refetch
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useSubscription
});
//# sourceMappingURL=useSubscription.cjs.map