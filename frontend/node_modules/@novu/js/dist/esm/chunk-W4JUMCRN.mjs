import { __async, __spreadProps, __spreadValues, __privateAdd, __privateSet, __privateGet } from './chunk-STZMOEWR.mjs';

// src/ui/internal/buildContextKey.ts
function buildContextKey(context) {
  if (!context) {
    return "";
  }
  const keys = [];
  for (const [type, value] of Object.entries(context)) {
    if (value) {
      const id = typeof value === "string" ? value : value.id;
      keys.push(`${type}:${id}`);
    }
  }
  return keys.sort().join(",");
}

// src/ui/internal/buildSubscriber.ts
function buildSubscriber({
  subscriberId,
  subscriber
}) {
  if (subscriber) {
    return typeof subscriber === "string" ? { subscriberId: subscriber } : subscriber;
  }
  if (subscriberId) {
    return { subscriberId };
  }
  return { subscriberId: "" };
}

// src/ui/internal/buildSubscriptionIdentifier.ts
function buildSubscriptionIdentifier({
  topicKey,
  subscriberId,
  contextKey
}) {
  const base = `tk_${topicKey}:si_${subscriberId}`;
  if (contextKey && contextKey.length > 0) {
    return `${base}:ctx_${contextKey}`;
  }
  return base;
}

// src/types.ts
var NotificationStatus = /* @__PURE__ */ ((NotificationStatus2) => {
  NotificationStatus2["READ"] = "read";
  NotificationStatus2["SEEN"] = "seen";
  NotificationStatus2["SNOOZED"] = "snoozed";
  NotificationStatus2["UNREAD"] = "unread";
  NotificationStatus2["UNSEEN"] = "unseen";
  NotificationStatus2["UNSNOOZED"] = "unsnoozed";
  return NotificationStatus2;
})(NotificationStatus || {});
var PreferenceLevel = /* @__PURE__ */ ((PreferenceLevel2) => {
  PreferenceLevel2["GLOBAL"] = "global";
  PreferenceLevel2["TEMPLATE"] = "template";
  return PreferenceLevel2;
})(PreferenceLevel || {});
var ChannelType = /* @__PURE__ */ ((ChannelType2) => {
  ChannelType2["IN_APP"] = "in_app";
  ChannelType2["EMAIL"] = "email";
  ChannelType2["SMS"] = "sms";
  ChannelType2["CHAT"] = "chat";
  ChannelType2["PUSH"] = "push";
  return ChannelType2;
})(ChannelType || {});
var WebSocketEvent = /* @__PURE__ */ ((WebSocketEvent2) => {
  WebSocketEvent2["RECEIVED"] = "notification_received";
  WebSocketEvent2["UNREAD"] = "unread_count_changed";
  WebSocketEvent2["UNSEEN"] = "unseen_count_changed";
  return WebSocketEvent2;
})(WebSocketEvent || {});
var SeverityLevelEnum = /* @__PURE__ */ ((SeverityLevelEnum2) => {
  SeverityLevelEnum2["HIGH"] = "high";
  SeverityLevelEnum2["MEDIUM"] = "medium";
  SeverityLevelEnum2["LOW"] = "low";
  SeverityLevelEnum2["NONE"] = "none";
  return SeverityLevelEnum2;
})(SeverityLevelEnum || {});
var WorkflowCriticalityEnum = /* @__PURE__ */ ((WorkflowCriticalityEnum2) => {
  WorkflowCriticalityEnum2["CRITICAL"] = "critical";
  WorkflowCriticalityEnum2["NON_CRITICAL"] = "nonCritical";
  WorkflowCriticalityEnum2["ALL"] = "all";
  return WorkflowCriticalityEnum2;
})(WorkflowCriticalityEnum || {});

// src/utils/errors.ts
var NovuError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
};

// src/notifications/helpers.ts
var read = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString(),
      isArchived: false,
      archivedAt: void 0
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.read.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.read(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.read.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.read.resolved", { args, error });
    return { error: new NovuError("Failed to read notification", error) };
  }
});
var unread = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: false,
      readAt: null,
      isArchived: false,
      archivedAt: void 0
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unread.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unread(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unread.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unread.resolved", { args, error });
    return { error: new NovuError("Failed to unread notification", error) };
  }
});
var seen = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSeen: true
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.seen.pending", {
      args,
      data: optimisticValue
    });
    yield apiService.seen(notificationId);
    if (!optimisticValue) {
      throw new Error("Failed to create optimistic value for notification");
    }
    const updatedNotification = new Notification(optimisticValue, emitter, apiService);
    emitter.emit("notification.seen.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.seen.resolved", { args, error });
    return { error: new NovuError("Failed to mark notification as seen", error) };
  }
});
var archive = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: true,
      archivedAt: (/* @__PURE__ */ new Date()).toISOString(),
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.archive.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.archive(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.archive.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.archive.resolved", { args, error });
    return { error: new NovuError("Failed to archive notification", error) };
  }
});
var unarchive = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: false,
      archivedAt: null,
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unarchive.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unarchive(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unarchive.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unarchive.resolved", { args, error });
    return { error: new NovuError("Failed to unarchive notification", error) };
  }
});
var snooze = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: true,
      snoozedUntil: args.snoozeUntil
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.snooze.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.snooze(notificationId, args.snoozeUntil);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.snooze.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.snooze.resolved", { args, error });
    return { error: new NovuError("Failed to snooze notification", error) };
  }
});
var unsnooze = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: false,
      snoozedUntil: null
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unsnooze.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unsnooze(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unsnooze.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unsnooze.resolved", { args, error });
    return { error: new NovuError("Failed to unsnooze notification", error) };
  }
});
var completeAction = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args,
  actionType
}) {
  const optimisticUpdate = actionType === "primary" /* PRIMARY */ ? {
    primaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.primaryAction : {}), {
      isCompleted: true
    })
  } : {
    secondaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.secondaryAction : {}), {
      isCompleted: true
    })
  };
  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService
  });
  try {
    emitter.emit("notification.complete_action.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.completeAction({ actionType, notificationId });
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.complete_action.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.complete_action.resolved", { args, error });
    return { error: new NovuError(`Failed to complete ${actionType} action on the notification`, error) };
  }
});
var revertAction = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args,
  actionType
}) {
  const optimisticUpdate = actionType === "primary" /* PRIMARY */ ? {
    primaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.primaryAction : {}), {
      isCompleted: false
    })
  } : {
    secondaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.secondaryAction : {}), {
      isCompleted: false
    })
  };
  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService
  });
  try {
    emitter.emit("notification.revert_action.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.revertAction({ actionType, notificationId });
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.revert_action.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.revert_action.resolved", { args, error });
    return { error: new NovuError("Failed to fetch notifications", error) };
  }
});
var getNotificationDetails = (args, update, dependencies) => {
  if ("notification" in args) {
    return {
      notificationId: args.notification.id,
      optimisticValue: new Notification(
        __spreadValues(__spreadValues({}, args.notification), update),
        dependencies.emitter,
        dependencies.apiService
      )
    };
  } else {
    return {
      notificationId: args.notificationId
    };
  }
};
var readAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), {
          isRead: true,
          readAt: (/* @__PURE__ */ new Date()).toISOString(),
          isArchived: false,
          archivedAt: void 0
        }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.read_all.pending", { args: { tags, data }, data: optimisticNotifications });
    yield inboxService.readAll({ tags, data });
    emitter.emit("notifications.read_all.resolved", { args: { tags, data }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.read_all.resolved", { args: { tags, data }, error });
    return { error: new NovuError("Failed to read all notifications", error) };
  }
});
var seenAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  notificationIds,
  tags,
  data
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    const filteredNotifications = notificationIds && notificationIds.length > 0 ? notifications.filter((notification) => notificationIds.includes(notification.id)) : notifications;
    const optimisticNotifications = filteredNotifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), {
          isSeen: true,
          firstSeenAt: notification.firstSeenAt || (/* @__PURE__ */ new Date()).toISOString()
        }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.seen_all.pending", {
      args: { notificationIds, tags, data },
      data: optimisticNotifications
    });
    yield inboxService.markAsSeen({ notificationIds, tags, data });
    emitter.emit("notifications.seen_all.resolved", {
      args: { notificationIds, tags, data },
      data: optimisticNotifications
    });
    return {};
  } catch (error) {
    emitter.emit("notifications.seen_all.resolved", { args: { notificationIds, tags, data }, error });
    return { error: new NovuError("Failed to mark all notifications as seen", error) };
  }
});
var archiveAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), {
          isRead: true,
          readAt: (/* @__PURE__ */ new Date()).toISOString(),
          isArchived: true,
          archivedAt: (/* @__PURE__ */ new Date()).toISOString()
        }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.archive_all.pending", { args: { tags, data }, data: optimisticNotifications });
    yield inboxService.archiveAll({ tags, data });
    emitter.emit("notifications.archive_all.resolved", { args: { tags, data }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.archive_all.resolved", { args: { tags, data }, error });
    return { error: new NovuError("Failed to archive all notifications", error) };
  }
});
var archiveAllRead = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data, read: true });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), { isArchived: true, archivedAt: (/* @__PURE__ */ new Date()).toISOString() }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.archive_all_read.pending", { args: { tags, data }, data: optimisticNotifications });
    yield inboxService.archiveAllRead({ tags, data });
    emitter.emit("notifications.archive_all_read.resolved", { args: { tags, data }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.archive_all_read.resolved", { args: { tags, data }, error });
    return { error: new NovuError("Failed to archive all read notifications", error) };
  }
});
var deleteNotification = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId } = getNotificationDetails(
    args,
    {},
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.delete.pending", {
      args
    });
    yield apiService.delete(notificationId);
    emitter.emit("notification.delete.resolved", { args });
    return {};
  } catch (error) {
    emitter.emit("notification.delete.resolved", { args, error });
    return { error: new NovuError("Failed to delete notification", error) };
  }
});
var deleteAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    emitter.emit("notifications.delete_all.pending", { args: { tags, data }, data: notifications });
    yield inboxService.deleteAll({ tags, data });
    emitter.emit("notifications.delete_all.resolved", { args: { tags, data } });
    return {};
  } catch (error) {
    emitter.emit("notifications.delete_all.resolved", { args: { tags, data }, error });
    return { error: new NovuError("Failed to delete all notifications", error) };
  }
});

// src/notifications/notification.ts
var _emitter, _inboxService;
var Notification = class {
  constructor(notification, emitter, inboxService) {
    __privateAdd(this, _emitter);
    __privateAdd(this, _inboxService);
    __privateSet(this, _emitter, emitter);
    __privateSet(this, _inboxService, inboxService);
    this.id = notification.id;
    this.transactionId = notification.transactionId;
    this.subject = notification.subject;
    this.body = notification.body;
    this.to = notification.to;
    this.isRead = notification.isRead;
    this.isSeen = notification.isSeen;
    this.isArchived = notification.isArchived;
    this.isSnoozed = notification.isSnoozed;
    this.snoozedUntil = notification.snoozedUntil;
    this.deliveredAt = notification.deliveredAt;
    this.createdAt = notification.createdAt;
    this.readAt = notification.readAt;
    this.firstSeenAt = notification.firstSeenAt;
    this.archivedAt = notification.archivedAt;
    this.avatar = notification.avatar;
    this.primaryAction = notification.primaryAction;
    this.secondaryAction = notification.secondaryAction;
    this.channelType = notification.channelType;
    this.tags = notification.tags;
    this.redirect = notification.redirect;
    this.data = notification.data;
    this.workflow = notification.workflow;
    this.severity = notification.severity;
  }
  read() {
    return read({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  unread() {
    return unread({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  seen() {
    return seen({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  archive() {
    return archive({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  unarchive() {
    return unarchive({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  delete() {
    return deleteNotification({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  snooze(snoozeUntil) {
    return snooze({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this,
        snoozeUntil
      }
    });
  }
  unsnooze() {
    return unsnooze({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: { notification: this }
    });
  }
  completePrimary() {
    if (!this.primaryAction) {
      throw new Error("Primary action is not available");
    }
    return completeAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "primary" /* PRIMARY */
    });
  }
  completeSecondary() {
    if (!this.primaryAction) {
      throw new Error("Secondary action is not available");
    }
    return completeAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "secondary" /* SECONDARY */
    });
  }
  revertPrimary() {
    if (!this.primaryAction) {
      throw new Error("Primary action is not available");
    }
    return revertAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "primary" /* PRIMARY */
    });
  }
  revertSecondary() {
    if (!this.primaryAction) {
      throw new Error("Secondary action is not available");
    }
    return revertAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "secondary" /* SECONDARY */
    });
  }
  on(eventName, listener) {
    const cleanup = __privateGet(this, _emitter).on(eventName, listener);
    return () => {
      cleanup();
    };
  }
  /**
   * @deprecated
   * Use the cleanup function returned by the "on" method instead.
   */
  off(eventName, listener) {
    __privateGet(this, _emitter).off(eventName, listener);
  }
};
_emitter = new WeakMap();
_inboxService = new WeakMap();

// src/ui/internal/createNotification.ts
function createNotification({
  emitter,
  inboxService,
  notification
}) {
  return new Notification(notification, emitter, inboxService);
}

// src/ui/internal/parseMarkdown.tsx
function getTokenType(isBold, isItalic) {
  if (isBold && isItalic) return "boldItalic";
  if (isBold) return "bold";
  if (isItalic) return "italic";
  return "text";
}
var parseMarkdownIntoTokens = (text) => {
  const tokens = [];
  let buffer = "";
  let isBold = false;
  let isItalic = false;
  let lastDoubleAsteriskEnd = -2;
  for (let i = 0; i < text.length; i += 1) {
    if (text[i] === "\\" && text[i + 1] === "*") {
      buffer += "*";
      i += 1;
    } else if (text[i] === "*" && text[i + 1] === "*") {
      if (buffer) {
        tokens.push({
          type: getTokenType(isBold, isItalic),
          content: buffer
        });
        buffer = "";
      }
      isBold = !isBold;
      lastDoubleAsteriskEnd = i + 1;
      i += 1;
    } else if (text[i] === "*") {
      const prevIsStar = i > 0 && text[i - 1] === "*";
      const prevWasConsumed = lastDoubleAsteriskEnd === i - 1;
      if (prevIsStar && !prevWasConsumed) {
        buffer += text[i];
      } else {
        if (buffer) {
          tokens.push({
            type: getTokenType(isBold, isItalic),
            content: buffer
          });
          buffer = "";
        }
        isItalic = !isItalic;
      }
    } else {
      buffer += text[i];
    }
  }
  if (buffer) {
    tokens.push({
      type: getTokenType(isBold, isItalic),
      content: buffer
    });
  }
  return tokens;
};

export { ChannelType, Notification, NotificationStatus, NovuError, PreferenceLevel, SeverityLevelEnum, WebSocketEvent, WorkflowCriticalityEnum, archive, archiveAll, archiveAllRead, buildContextKey, buildSubscriber, buildSubscriptionIdentifier, completeAction, createNotification, deleteAll, deleteNotification, parseMarkdownIntoTokens, read, readAll, revertAction, seen, seenAll, snooze, unarchive, unread, unsnooze };
