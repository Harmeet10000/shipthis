import { RulesLogic } from 'json-logic-js';

type HttpClientOptions = {
    apiVersion?: string;
    apiUrl?: string;
    /**
     * @deprecated User-Agent header is not reliable in browsers. Use Novu-Client-Version instead.
     */
    userAgent?: string;
    headers?: Record<string, string>;
};

declare class SubscriptionsCache {
    #private;
    constructor({ emitterInstance, inboxServiceInstance, useCache, }: {
        emitterInstance: NovuEventEmitter;
        inboxServiceInstance: InboxService;
        useCache: boolean;
    });
    private handleCreate;
    private handleUpdate;
    private handlePreferenceUpdate;
    private handleBulkPreferenceUpdate;
    private updateSubscriptionPreferences;
    private createUpdatedSubscription;
    private handleDelete;
    private handleDeleteByIdentifier;
    has(args: ListSubscriptionsArgs): boolean;
    set(args: ListSubscriptionsArgs, data: TopicSubscription[]): void;
    setOne(args: GetSubscriptionArgs, data: TopicSubscription): void;
    getAll(args: ListSubscriptionsArgs): TopicSubscription[] | undefined;
    get(args: GetSubscriptionArgs): TopicSubscription | undefined;
    invalidate(args: {
        topicKey: string;
    }): void;
    clearAll(): void;
}

declare class NovuError extends Error {
    originalError: Error;
    constructor(message: string, originalError: unknown);
}

type ListPreferencesArgs = {
    tags?: string[];
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
    criticality?: WorkflowCriticalityEnum;
};
type BasePreferenceArgs = {
    workflowId: string;
    channels: ChannelPreference;
};
type InstancePreferenceArgs = {
    preference: Preference;
    channels: ChannelPreference;
};
type UpdatePreferenceArgs = BasePreferenceArgs | InstancePreferenceArgs;
type UpdateScheduleArgs = {
    isEnabled?: boolean;
    weeklySchedule?: WeeklySchedule;
};

declare class PreferencesCache {
    #private;
    constructor({ emitterInstance }: {
        emitterInstance: NovuEventEmitter;
    });
    private updatePreference;
    private updatePreferenceSchedule;
    private handleScheduleEvent;
    private handlePreferenceEvent;
    has(args: ListPreferencesArgs): boolean;
    set(args: ListPreferencesArgs, data: Preference[]): void;
    getAll(args: ListPreferencesArgs): Preference[] | undefined;
    clearAll(): void;
}

type ScheduleLike = Partial<Pick<Schedule, 'isEnabled' | 'weeklySchedule'>>;
declare class Schedule {
    #private;
    readonly isEnabled: boolean | undefined;
    readonly weeklySchedule: WeeklySchedule | undefined;
    constructor(schedule: ScheduleLike, { emitterInstance, inboxServiceInstance, cache, useCache, }: {
        emitterInstance: NovuEventEmitter;
        inboxServiceInstance: InboxService;
        cache: ScheduleCache;
        useCache: boolean;
    });
    update(args: UpdateScheduleArgs): Result<Schedule>;
}

declare class ScheduleCache {
    #private;
    constructor({ emitterInstance }: {
        emitterInstance: NovuEventEmitter;
    });
    private updateScheduleInCache;
    private handleScheduleEvent;
    has(): boolean;
    set(data: Schedule): void;
    getAll(): Schedule | undefined;
    clearAll(): void;
}

type PreferenceLike = Pick<Preference, 'level' | 'enabled' | 'channels' | 'workflow'> & {
    schedule?: ScheduleLike;
};
declare class Preference {
    #private;
    readonly level: PreferenceLevel;
    readonly enabled: boolean;
    readonly channels: ChannelPreference;
    readonly workflow?: Workflow;
    schedule: Schedule;
    constructor(preference: PreferenceLike, { emitterInstance, inboxServiceInstance, cache, scheduleCache, useCache, }: {
        emitterInstance: NovuEventEmitter;
        inboxServiceInstance: InboxService;
        cache: PreferencesCache;
        scheduleCache: ScheduleCache;
        useCache: boolean;
    });
    update({ channels, channelPreferences, }: Prettify<Pick<UpdatePreferenceArgs, 'channels'> & {
        /** @deprecated Use channels instead */
        channelPreferences?: ChannelPreference;
    }>): Result<Preference>;
}

declare global {
    /**
     * If you want to provide custom types for the notification.data object,
     * simply redeclare this rule in the global namespace.
     * Every notification object will use the provided type.
     */
    interface NotificationData {
        [k: string]: unknown;
    }
}
declare enum NotificationStatus {
    READ = "read",
    SEEN = "seen",
    SNOOZED = "snoozed",
    UNREAD = "unread",
    UNSEEN = "unseen",
    UNSNOOZED = "unsnoozed"
}
declare enum PreferenceLevel {
    GLOBAL = "global",
    TEMPLATE = "template"
}
declare enum ChannelType {
    IN_APP = "in_app",
    EMAIL = "email",
    SMS = "sms",
    CHAT = "chat",
    PUSH = "push"
}
declare enum WebSocketEvent {
    RECEIVED = "notification_received",
    UNREAD = "unread_count_changed",
    UNSEEN = "unseen_count_changed"
}
declare enum SeverityLevelEnum {
    HIGH = "high",
    MEDIUM = "medium",
    LOW = "low",
    NONE = "none"
}
declare enum WorkflowCriticalityEnum {
    CRITICAL = "critical",
    NON_CRITICAL = "nonCritical",
    ALL = "all"
}
type UnreadCount = {
    total: number;
    severity: Record<SeverityLevelEnum, number>;
};
type Session = {
    token: string;
    /** @deprecated Use unreadCount.total instead */
    totalUnreadCount: number;
    unreadCount: UnreadCount;
    removeNovuBranding: boolean;
    isDevelopmentMode: boolean;
    maxSnoozeDurationHours: number;
    applicationIdentifier?: string;
    contextKeys?: string[];
};
type Subscriber = {
    id?: string;
    subscriberId: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
    avatar?: string;
    locale?: string;
    data?: Record<string, unknown>;
    timezone?: string;
};
type Redirect = {
    url: string;
    target?: '_self' | '_blank' | '_parent' | '_top' | '_unfencedTop';
};
declare enum ActionTypeEnum {
    PRIMARY = "primary",
    SECONDARY = "secondary"
}
type Action = {
    label: string;
    isCompleted: boolean;
    redirect?: Redirect;
};
type Workflow = {
    id: string;
    identifier: string;
    name: string;
    critical: boolean;
    tags?: string[];
    severity: SeverityLevelEnum;
};
type InboxNotification = {
    id: string;
    transactionId: string;
    subject?: string;
    body: string;
    to: Subscriber;
    isRead: boolean;
    isSeen: boolean;
    isArchived: boolean;
    isSnoozed: boolean;
    snoozedUntil?: string | null;
    deliveredAt?: string[];
    createdAt: string;
    readAt?: string | null;
    firstSeenAt?: string | null;
    archivedAt?: string | null;
    avatar?: string;
    primaryAction?: Action;
    secondaryAction?: Action;
    channelType: ChannelType;
    tags?: string[];
    data?: NotificationData;
    redirect?: Redirect;
    workflow?: Workflow;
    severity: SeverityLevelEnum;
};
type NotificationFilter = {
    tags?: string[];
    read?: boolean;
    archived?: boolean;
    snoozed?: boolean;
    seen?: boolean;
    data?: Record<string, unknown>;
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
};
type ChannelPreference = {
    email?: boolean;
    sms?: boolean;
    in_app?: boolean;
    chat?: boolean;
    push?: boolean;
};
type TimeRange = {
    start: string;
    end: string;
};
type DaySchedule = {
    isEnabled: boolean;
    hours?: Array<TimeRange>;
};
type WeeklySchedule = {
    monday?: DaySchedule;
    tuesday?: DaySchedule;
    wednesday?: DaySchedule;
    thursday?: DaySchedule;
    friday?: DaySchedule;
    saturday?: DaySchedule;
    sunday?: DaySchedule;
};
type DefaultSchedule = {
    isEnabled?: boolean;
    weeklySchedule?: WeeklySchedule;
};
type ContextValue = string | {
    id: string;
    data?: Record<string, unknown>;
};
type Context = Partial<Record<string, ContextValue>>;
type PreferencesResponse = {
    level: PreferenceLevel;
    enabled: boolean;
    condition?: RulesLogic;
    subscriptionId?: string;
    channels: ChannelPreference;
    overrides?: IPreferenceOverride[];
    workflow?: Workflow;
    schedule?: {
        isEnabled: boolean;
        weeklySchedule?: WeeklySchedule;
    };
};
declare enum PreferenceOverrideSourceEnum {
    SUBSCRIBER = "subscriber",
    TEMPLATE = "template",
    WORKFLOW_OVERRIDE = "workflowOverride"
}
type IPreferenceOverride = {
    channel: ChannelType;
    source: PreferenceOverrideSourceEnum;
};
type SubscriptionPreferenceResponse = Omit<PreferencesResponse, 'subscriptionId' | 'workflow' | 'schedule' | 'level' | 'channels'> & {
    subscriptionId: string;
    workflow: Workflow;
};
type SubscriptionResponse = {
    id: string;
    identifier: string;
    name?: string;
    preferences?: Array<SubscriptionPreferenceResponse>;
};
type Options = {
    refetch?: boolean;
    useCache?: boolean;
};
type Result<D = undefined, E = NovuError> = Promise<{
    data?: D;
    error?: E;
}>;
type KeylessNovuOptions = {} & {
    [K in string]?: never;
};
type StandardNovuOptions = {
    /** @deprecated Use apiUrl instead  */
    backendUrl?: string;
    /** @internal Should be used internally for testing purposes */
    __userAgent?: string;
    applicationIdentifier: string;
    subscriberHash?: string;
    contextHash?: string;
    apiUrl?: string;
    socketUrl?: string;
    useCache?: boolean;
    defaultSchedule?: DefaultSchedule;
    context?: Context;
} & ({
    /** @deprecated Use subscriber prop instead */
    subscriberId: string;
    subscriber?: never;
} | {
    subscriber: Subscriber | string;
    subscriberId?: never;
});
type NovuOptions = KeylessNovuOptions | StandardNovuOptions;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

declare class SubscriptionPreference {
    #private;
    readonly subscriptionId: string;
    readonly workflow: Workflow;
    readonly enabled: boolean;
    readonly condition?: RulesLogic;
    constructor(preference: SubscriptionPreferenceResponse, emitter: NovuEventEmitter, inboxService: InboxService, cache: SubscriptionsCache, useCache?: boolean);
    update(args: {
        value: boolean | RulesLogic;
    }): Result<SubscriptionPreference>;
}

declare class TopicSubscription {
    #private;
    readonly id: string;
    readonly identifier: string;
    readonly topicKey: string;
    readonly preferences?: Array<SubscriptionPreference> | undefined;
    constructor(subscription: SubscriptionResponse & {
        topicKey: string;
    }, emitter: NovuEventEmitter, inboxService: InboxService, cache: SubscriptionsCache, useCache?: boolean);
    update(args: BaseUpdateSubscriptionArgs): Result<TopicSubscription>;
    update(args: InstanceUpdateSubscriptionArgs): Result<TopicSubscription>;
    updatePreference(args: BaseSubscriptionPreferenceArgs): Result<SubscriptionPreference>;
    updatePreference(args: InstanceSubscriptionPreferenceArgs): Result<SubscriptionPreference>;
    bulkUpdatePreferences(args: Array<BaseSubscriptionPreferenceArgs>): Result<SubscriptionPreference[]>;
    bulkUpdatePreferences(args: Array<InstanceSubscriptionPreferenceArgs>): Result<SubscriptionPreference[]>;
    delete(): Result<void>;
}

type WorkflowIdentifierOrId = string;
type WorkflowFilter = {
    workflowId: WorkflowIdentifierOrId;
    enabled?: boolean;
    condition?: RulesLogic;
    filter?: never;
};
type WorkflowGroupFilter = {
    filter: {
        workflowIds?: Array<WorkflowIdentifierOrId>;
        tags?: string[];
    };
    enabled?: boolean;
    condition?: RulesLogic;
    workflowId?: never;
};
type PreferenceFilter = WorkflowIdentifierOrId | WorkflowFilter | WorkflowGroupFilter;
type ListSubscriptionsArgs = {
    topicKey: string;
};
type GetSubscriptionArgs = {
    topicKey: string;
    identifier?: string;
    workflowIds?: string[];
    tags?: string[];
};
type CreateSubscriptionArgs = {
    topicKey: string;
    topicName?: string;
    identifier?: string;
    name?: string;
    preferences?: Array<PreferenceFilter> | undefined;
};
type BaseUpdateSubscriptionArgs = {
    topicKey: string;
    identifier: string;
    name?: string;
    preferences?: Array<PreferenceFilter>;
};
type InstanceUpdateSubscriptionArgs = {
    subscription: TopicSubscription;
    name?: string;
    preferences?: Array<PreferenceFilter>;
};
type UpdateSubscriptionArgs = BaseUpdateSubscriptionArgs | InstanceUpdateSubscriptionArgs;
type BaseSubscriptionPreferenceArgs = {
    workflowId: string;
    value: boolean | RulesLogic;
};
type InstanceSubscriptionPreferenceArgs = {
    preference: SubscriptionPreference;
    value: boolean | RulesLogic;
};
type UpdateSubscriptionPreferenceArgs = BaseSubscriptionPreferenceArgs | InstanceSubscriptionPreferenceArgs;
type BaseDeleteSubscriptionArgs = {
    identifier: string;
    topicKey: string;
};
type InstanceDeleteSubscriptionArgs = {
    subscription: TopicSubscription;
};
type DeleteSubscriptionArgs = BaseDeleteSubscriptionArgs | InstanceDeleteSubscriptionArgs;

type InboxServiceOptions = HttpClientOptions;
declare class InboxService {
    #private;
    isSessionInitialized: boolean;
    constructor(options?: InboxServiceOptions);
    initializeSession({ applicationIdentifier, subscriberHash, contextHash, subscriber, defaultSchedule, context, }: {
        applicationIdentifier?: string;
        subscriberHash?: string;
        contextHash?: string;
        subscriber?: Subscriber;
        defaultSchedule?: DefaultSchedule;
        context?: Context;
    }): Promise<Session>;
    fetchNotifications({ after, archived, limit, offset, read, tags, snoozed, seen, data, severity, }: {
        tags?: string[];
        read?: boolean;
        archived?: boolean;
        snoozed?: boolean;
        seen?: boolean;
        limit?: number;
        after?: string;
        offset?: number;
        data?: Record<string, unknown>;
        severity?: SeverityLevelEnum | SeverityLevelEnum[];
    }): Promise<{
        data: InboxNotification[];
        hasMore: boolean;
        filter: NotificationFilter;
    }>;
    count({ filters, }: {
        filters: Array<{
            tags?: string[];
            read?: boolean;
            archived?: boolean;
            snoozed?: boolean;
            seen?: boolean;
            data?: Record<string, unknown>;
            severity?: SeverityLevelEnum | SeverityLevelEnum[];
        }>;
    }): Promise<{
        data: Array<{
            count: number;
            filter: NotificationFilter;
        }>;
    }>;
    read(notificationId: string): Promise<InboxNotification>;
    unread(notificationId: string): Promise<InboxNotification>;
    archive(notificationId: string): Promise<InboxNotification>;
    unarchive(notificationId: string): Promise<InboxNotification>;
    snooze(notificationId: string, snoozeUntil: string): Promise<InboxNotification>;
    unsnooze(notificationId: string): Promise<InboxNotification>;
    readAll({ tags, data }: {
        tags?: string[];
        data?: Record<string, unknown>;
    }): Promise<void>;
    archiveAll({ tags, data }: {
        tags?: string[];
        data?: Record<string, unknown>;
    }): Promise<void>;
    archiveAllRead({ tags, data }: {
        tags?: string[];
        data?: Record<string, unknown>;
    }): Promise<void>;
    delete(notificationId: string): Promise<void>;
    deleteAll({ tags, data }: {
        tags?: string[];
        data?: Record<string, unknown>;
    }): Promise<void>;
    markAsSeen({ notificationIds, tags, data, }: {
        notificationIds?: string[];
        tags?: string[];
        data?: Record<string, unknown>;
    }): Promise<void>;
    seen(notificationId: string): Promise<void>;
    completeAction({ actionType, notificationId, }: {
        notificationId: string;
        actionType: ActionTypeEnum;
    }): Promise<InboxNotification>;
    revertAction({ actionType, notificationId, }: {
        notificationId: string;
        actionType: ActionTypeEnum;
    }): Promise<InboxNotification>;
    fetchPreferences({ tags, severity, criticality, }: {
        tags?: string[];
        severity?: SeverityLevelEnum | SeverityLevelEnum[];
        criticality: WorkflowCriticalityEnum;
    }): Promise<PreferencesResponse[]>;
    bulkUpdatePreferences(preferences: Array<{
        workflowId: string;
    } & ChannelPreference>): Promise<PreferencesResponse[]>;
    updateGlobalPreferences(preferences: ChannelPreference & {
        schedule?: {
            isEnabled?: boolean;
            weeklySchedule?: WeeklySchedule;
        };
    }): Promise<PreferencesResponse>;
    updateWorkflowPreferences({ workflowId, channels, }: {
        workflowId: string;
        channels: ChannelPreference;
    }): Promise<PreferencesResponse>;
    fetchGlobalPreferences(): Promise<PreferencesResponse>;
    triggerHelloWorldEvent(): Promise<unknown>;
    fetchSubscriptions(topicKey: string): Promise<SubscriptionResponse[]>;
    getSubscription(topicKey: string, identifier?: string, workflowIds?: string[], tags?: string[]): Promise<SubscriptionResponse | undefined>;
    createSubscription({ identifier, name, topicKey, topicName, preferences, }: {
        identifier?: string;
        name?: string;
        topicKey: string;
        topicName?: string;
        preferences?: Array<PreferenceFilter>;
    }): Promise<SubscriptionResponse>;
    updateSubscription({ topicKey, identifier, name, preferences, }: {
        topicKey: string;
        identifier: string;
        name?: string;
        preferences?: Array<PreferenceFilter>;
    }): Promise<SubscriptionResponse>;
    updateSubscriptionPreference({ subscriptionIdentifier, workflowId, enabled, condition, email, sms, in_app, chat, push, }: {
        subscriptionIdentifier: string;
        workflowId: string;
        enabled?: boolean;
        condition?: RulesLogic;
        email?: boolean;
        sms?: boolean;
        in_app?: boolean;
        chat?: boolean;
        push?: boolean;
    }): Promise<SubscriptionPreferenceResponse>;
    bulkUpdateSubscriptionPreferences(preferences: Array<{
        subscriptionIdentifier: string;
        workflowId: string;
        enabled?: boolean;
        condition?: RulesLogic;
        email?: boolean;
        sms?: boolean;
        in_app?: boolean;
        chat?: boolean;
        push?: boolean;
    }>): Promise<SubscriptionPreferenceResponse[]>;
    deleteSubscription({ topicKey, identifier }: {
        topicKey: string;
        identifier: string;
    }): Promise<void>;
}

declare class Notification implements Pick<NovuEventEmitter, 'on'>, InboxNotification {
    #private;
    readonly id: InboxNotification['id'];
    readonly transactionId: InboxNotification['transactionId'];
    readonly subject?: InboxNotification['subject'];
    readonly body: InboxNotification['body'];
    readonly to: InboxNotification['to'];
    readonly isRead: InboxNotification['isRead'];
    readonly isSeen: InboxNotification['isSeen'];
    readonly isArchived: InboxNotification['isArchived'];
    readonly isSnoozed: InboxNotification['isSnoozed'];
    readonly snoozedUntil?: InboxNotification['snoozedUntil'];
    readonly deliveredAt?: InboxNotification['deliveredAt'];
    readonly createdAt: InboxNotification['createdAt'];
    readonly readAt?: InboxNotification['readAt'];
    readonly firstSeenAt?: InboxNotification['firstSeenAt'];
    readonly archivedAt?: InboxNotification['archivedAt'];
    readonly avatar?: InboxNotification['avatar'];
    readonly primaryAction?: InboxNotification['primaryAction'];
    readonly secondaryAction?: InboxNotification['secondaryAction'];
    readonly channelType: InboxNotification['channelType'];
    readonly tags: InboxNotification['tags'];
    readonly redirect: InboxNotification['redirect'];
    readonly data?: InboxNotification['data'];
    readonly workflow?: InboxNotification['workflow'];
    readonly severity: InboxNotification['severity'];
    constructor(notification: InboxNotification, emitter: NovuEventEmitter, inboxService: InboxService);
    read(): Result<Notification>;
    unread(): Result<Notification>;
    seen(): Result<Notification>;
    archive(): Result<Notification>;
    unarchive(): Result<Notification>;
    delete(): Result<void>;
    snooze(snoozeUntil: string): Result<Notification>;
    unsnooze(): Result<Notification>;
    completePrimary(): Result<Notification>;
    completeSecondary(): Result<Notification>;
    revertPrimary(): Result<Notification>;
    revertSecondary(): Result<Notification>;
    on<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): () => void;
    /**
     * @deprecated
     * Use the cleanup function returned by the "on" method instead.
     */
    off<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): void;
}

type ListNotificationsArgs = {
    tags?: string[];
    read?: boolean;
    data?: Record<string, unknown>;
    archived?: boolean;
    snoozed?: boolean;
    seen?: boolean;
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
    limit?: number;
    after?: string;
    offset?: number;
    useCache?: boolean;
};
type ListNotificationsResponse = {
    notifications: Notification[];
    hasMore: boolean;
    filter: NotificationFilter;
};
type FilterCountArgs = {
    tags?: string[];
    data?: Record<string, unknown>;
    read?: boolean;
    archived?: boolean;
    snoozed?: boolean;
    seen?: boolean;
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
};
type FiltersCountArgs = {
    filters: Array<{
        tags?: string[];
        read?: boolean;
        archived?: boolean;
        snoozed?: boolean;
        seen?: boolean;
        data?: Record<string, unknown>;
        severity?: SeverityLevelEnum | SeverityLevelEnum[];
    }>;
};
type CountArgs = undefined | FilterCountArgs | FiltersCountArgs;
type FilterCountResponse = {
    count: number;
    filter: NotificationFilter;
};
type FiltersCountResponse = {
    counts: Array<{
        count: number;
        filter: NotificationFilter;
    }>;
};
type CountResponse = FilterCountResponse | FiltersCountResponse;
type BaseArgs = {
    notificationId: string;
};
type InstanceArgs = {
    notification: Notification;
};
type ReadArgs = BaseArgs | InstanceArgs;
type UnreadArgs = BaseArgs | InstanceArgs;
type ArchivedArgs = BaseArgs | InstanceArgs;
type UnarchivedArgs = BaseArgs | InstanceArgs;
type DeletedArgs = BaseArgs | InstanceArgs;
type SeenArgs = BaseArgs | InstanceArgs;
type SnoozeArgs = (BaseArgs | InstanceArgs) & {
    snoozeUntil: string;
};
type UnsnoozeArgs = BaseArgs | InstanceArgs;
type CompleteArgs = BaseArgs | InstanceArgs;
type RevertArgs = BaseArgs | InstanceArgs;

type KeylessInitializeSessionArgs = {} & {
    [K in string]?: never;
};
type InitializeSessionArgs = KeylessInitializeSessionArgs | {
    applicationIdentifier: string;
    subscriber: Subscriber;
    subscriberHash?: string;
    contextHash?: string;
    defaultSchedule?: DefaultSchedule;
    context?: Context;
};

type NovuPendingEvent<A, D = undefined> = {
    args: A;
    data?: D;
};
type NovuResolvedEvent<A, D> = NovuPendingEvent<A, D> & {
    error?: unknown;
};
type EventName<T extends string> = `${T}.pending` | `${T}.resolved`;
type EventStatus<T extends string> = `${T extends `${infer _}.${infer __}.${infer V}` ? V : never}`;
type EventObject<K extends string, ARGS, DATA, EVENT_STATUS = EventStatus<K>> = EVENT_STATUS extends 'pending' ? NovuPendingEvent<ARGS, DATA> : NovuResolvedEvent<ARGS, DATA>;
type BaseEvents<T extends string, ARGS, DATA> = {
    [key in `${EventName<T>}`]: EventObject<key, ARGS, DATA>;
};
type SessionInitializeEvents = BaseEvents<'session.initialize', InitializeSessionArgs, Session>;
type NotificationsFetchEvents = BaseEvents<'notifications.list', ListNotificationsArgs, ListNotificationsResponse>;
type NotificationsFetchCountEvents = BaseEvents<'notifications.count', CountArgs, CountResponse>;
type NotificationReadEvents = BaseEvents<'notification.read', ReadArgs, Notification>;
type NotificationUnreadEvents = BaseEvents<'notification.unread', UnreadArgs, Notification>;
type NotificationSeenEvents = BaseEvents<'notification.seen', SeenArgs, Notification>;
type NotificationArchiveEvents = BaseEvents<'notification.archive', ArchivedArgs, Notification>;
type NotificationUnarchiveEvents = BaseEvents<'notification.unarchive', UnarchivedArgs, Notification>;
type NotificationDeleteEvents = BaseEvents<'notification.delete', DeletedArgs, Notification>;
type NotificationSnoozeEvents = BaseEvents<'notification.snooze', SnoozeArgs, Notification>;
type NotificationUnsnoozeEvents = BaseEvents<'notification.unsnooze', UnsnoozeArgs, Notification>;
type NotificationCompleteActionEvents = BaseEvents<'notification.complete_action', CompleteArgs, Notification>;
type NotificationRevertActionEvents = BaseEvents<'notification.revert_action', RevertArgs, Notification>;
type NotificationsReadAllEvents = BaseEvents<'notifications.read_all', {
    tags?: string[];
    data?: Record<string, unknown>;
}, Notification[]>;
type NotificationsSeenAllEvents = BaseEvents<'notifications.seen_all', {
    notificationIds: string[];
} | {
    tags?: string[];
    data?: Record<string, unknown>;
} | {}, Notification[]>;
type NotificationsArchivedAllEvents = BaseEvents<'notifications.archive_all', {
    tags?: string[];
    data?: Record<string, unknown>;
}, Notification[]>;
type NotificationsReadArchivedAllEvents = BaseEvents<'notifications.archive_all_read', {
    tags?: string[];
    data?: Record<string, unknown>;
}, Notification[]>;
type NotificationsDeletedAllEvents = BaseEvents<'notifications.delete_all', {
    tags?: string[];
    data?: Record<string, unknown>;
}, Notification[]>;
type PreferencesFetchEvents = BaseEvents<'preferences.list', ListPreferencesArgs, Preference[]>;
type PreferenceUpdateEvents = BaseEvents<'preference.update', UpdatePreferenceArgs, Preference>;
type PreferencesBulkUpdateEvents = BaseEvents<'preferences.bulk_update', Array<UpdatePreferenceArgs>, Preference[]>;
type PreferenceScheduleGetEvents = BaseEvents<'preference.schedule.get', undefined, Schedule>;
type PreferenceScheduleUpdateEvents = BaseEvents<'preference.schedule.update', UpdateScheduleArgs, Schedule>;
type SubscriptionsFetchEvents = BaseEvents<'subscriptions.list', ListSubscriptionsArgs, TopicSubscription[]>;
type SubscriptionGetEvents = BaseEvents<'subscription.get', GetSubscriptionArgs, TopicSubscription | null>;
type SubscriptionCreateEvents = BaseEvents<'subscription.create', CreateSubscriptionArgs, TopicSubscription>;
type SubscriptionUpdateEvents = BaseEvents<'subscription.update', UpdateSubscriptionArgs, TopicSubscription>;
type SubscriptionPreferenceUpdateEvents = BaseEvents<'subscription.preference.update', UpdateSubscriptionPreferenceArgs, SubscriptionPreference>;
type SubscriptionPreferencesBulkUpdateEvents = BaseEvents<'subscription.preferences.bulk_update', Array<UpdateSubscriptionPreferenceArgs & {
    subscriptionId: string;
}>, SubscriptionPreference[]>;
type SubscriptionDeleteEvents = BaseEvents<'subscription.delete', DeleteSubscriptionArgs, void>;
type SocketConnectEvents = BaseEvents<'socket.connect', {
    socketUrl: string;
}, undefined>;
type NotificationReceivedEvent = `notifications.${WebSocketEvent.RECEIVED}`;
type NotificationUnseenEvent = `notifications.${WebSocketEvent.UNSEEN}`;
type NotificationUnreadEvent = `notifications.${WebSocketEvent.UNREAD}`;
type SocketEvents = {
    [key in NotificationReceivedEvent]: {
        result: Notification;
    };
} & {
    [key in NotificationUnseenEvent]: {
        result: number;
    };
} & {
    [key in NotificationUnreadEvent]: {
        result: {
            total: number;
            severity: Record<string, number>;
        };
    };
};
/**
 * Events that are emitted by Novu Event Emitter.
 *
 * The event name consists of second pattern: module.action.status
 * - module: the name of the module
 * - action: the action that is being performed
 * - status: the status of the action, could be pending or resolved
 *
 * Each event has a corresponding payload that is associated with the event:
 * - pending: the args that are passed to the action and the optional optimistic value
 * - resolved: the args that are passed to the action and the result of the action or the error that is thrown
 */
type Events = SessionInitializeEvents & NotificationsFetchEvents & {
    'notifications.list.updated': {
        data: ListNotificationsResponse;
    };
} & NotificationsFetchCountEvents & PreferencesFetchEvents & {
    'preferences.list.updated': {
        data: Preference[];
    };
} & PreferenceUpdateEvents & PreferencesBulkUpdateEvents & PreferenceScheduleGetEvents & PreferenceScheduleUpdateEvents & {
    'preference.schedule.get.updated': {
        data: Schedule;
    };
} & SubscriptionsFetchEvents & SubscriptionGetEvents & SubscriptionCreateEvents & SubscriptionPreferenceUpdateEvents & SubscriptionUpdateEvents & SubscriptionPreferencesBulkUpdateEvents & SubscriptionDeleteEvents & {
    'subscriptions.list.updated': {
        data: {
            topicKey: string;
            subscriptions: TopicSubscription[];
        };
    };
} & SocketConnectEvents & SocketEvents & NotificationReadEvents & NotificationUnreadEvents & NotificationSeenEvents & NotificationArchiveEvents & NotificationUnarchiveEvents & NotificationDeleteEvents & NotificationSnoozeEvents & NotificationUnsnoozeEvents & NotificationCompleteActionEvents & NotificationRevertActionEvents & NotificationsReadAllEvents & NotificationsSeenAllEvents & NotificationsArchivedAllEvents & NotificationsReadArchivedAllEvents & NotificationsDeletedAllEvents;
type EventNames = keyof Events;
type SocketEventNames = keyof SocketEvents;
type EventHandler<T = unknown> = (event: T) => void;

declare class NovuEventEmitter {
    #private;
    constructor();
    on<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): () => void;
    off<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): void;
    emit<Key extends EventNames>(type: Key, event?: Events[Key]): void;
}

export { type InstancePreferenceArgs as $, WebSocketEvent as A, type BaseDeleteSubscriptionArgs as B, type CreateSubscriptionArgs as C, type DeleteSubscriptionArgs as D, type EventHandler as E, type FiltersCountResponse as F, type GetSubscriptionArgs as G, type WeeklySchedule as H, type InstanceDeleteSubscriptionArgs as I, WorkflowCriticalityEnum as J, NovuError as K, type ListSubscriptionsArgs as L, InboxService as M, type NotificationFilter as N, NovuEventEmitter as O, type PreferenceFilter as P, type Session as Q, type Result as R, SeverityLevelEnum as S, TopicSubscription as T, type UpdateSubscriptionArgs as U, ScheduleCache as V, type WorkflowFilter as W, type UpdateScheduleArgs as X, PreferencesCache as Y, type ListPreferencesArgs as Z, type BasePreferenceArgs as _, Notification as a, type ListNotificationsArgs as a0, type FilterCountArgs as a1, type FilterCountResponse as a2, type FiltersCountArgs as a3, type BaseArgs as a4, type InstanceArgs as a5, type SnoozeArgs as a6, SubscriptionsCache as a7, type Options as a8, type EventNames as a9, type ContextValue as aa, type Events as b, type SocketEventNames as c, type WorkflowGroupFilter as d, type WorkflowIdentifierOrId as e, type BaseUpdateSubscriptionArgs as f, type InstanceUpdateSubscriptionArgs as g, SubscriptionPreference as h, type UpdateSubscriptionPreferenceArgs as i, type ChannelPreference as j, ChannelType as k, type Context as l, type DaySchedule as m, type DefaultSchedule as n, type InboxNotification as o, type ListNotificationsResponse as p, NotificationStatus as q, type NovuOptions as r, Preference as s, PreferenceLevel as t, type PreferencesResponse as u, Schedule as v, type StandardNovuOptions as w, type Subscriber as x, type TimeRange as y, type UnreadCount as z };
