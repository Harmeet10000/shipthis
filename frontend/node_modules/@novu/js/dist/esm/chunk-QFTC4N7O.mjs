import { NovuError, buildSubscriber, buildContextKey, buildSubscriptionIdentifier, Notification, read, unread, seen, archive, unarchive, deleteNotification, snooze, unsnooze, completeAction, revertAction, readAll, seenAll, archiveAll, archiveAllRead, deleteAll, createNotification } from './chunk-W4JUMCRN.mjs';
import { __privateAdd, __privateSet, __spreadValues, __privateGet, __async, __spreadProps, __objRest, __privateMethod } from './chunk-STZMOEWR.mjs';
import mitt from 'mitt';
import 'event-target-polyfill';
import { WebSocket } from 'partysocket';
import io from 'socket.io-client';

// src/utils/arrays.ts
var arrayValuesEqual = (arr1, arr2) => {
  if (arr1 === arr2) {
    return true;
  }
  if (!arr1 || !arr2) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value, index) => value === arr2[index]);
};
var areTagsEqual = (tags1, tags2) => {
  return arrayValuesEqual(tags1, tags2) || !tags1 && (tags2 == null ? void 0 : tags2.length) === 0 || (tags1 == null ? void 0 : tags1.length) === 0 && !tags2;
};
var areSeveritiesEqual = (el1, el2) => {
  const severity1 = Array.isArray(el1) ? el1 : el1 ? [el1] : [];
  const severity2 = Array.isArray(el2) ? el2 : el2 ? [el2] : [];
  return arrayValuesEqual(severity1, severity2);
};
var areDataEqual = (data1, data2) => {
  if (!data1 && !data2) {
    return true;
  }
  if (!data1 || !data2) {
    return false;
  }
  try {
    return JSON.stringify(data1) === JSON.stringify(data2);
  } catch (e) {
    return false;
  }
};
var isSameFilter = (filter1, filter2) => {
  return areDataEqual(filter1.data, filter2.data) && areTagsEqual(filter1.tags, filter2.tags) && filter1.read === filter2.read && filter1.archived === filter2.archived && filter1.snoozed === filter2.snoozed && filter1.seen === filter2.seen && areSeveritiesEqual(filter1.severity, filter2.severity);
};
function checkNotificationDataFilter(notificationData, filterData) {
  if (!filterData || Object.keys(filterData).length === 0) {
    return true;
  }
  if (!notificationData) {
    return false;
  }
  return Object.entries(filterData).every(([key, filterValue]) => {
    const notifValue = notificationData[key];
    if (notifValue === void 0 && filterValue !== void 0) {
      return false;
    }
    if (Array.isArray(filterValue)) {
      if (Array.isArray(notifValue)) {
        if (filterValue.length !== notifValue.length) return false;
        const sortedFilterValue = [...filterValue].sort();
        const sortedNotifValue = [...notifValue].sort();
        return sortedFilterValue.every((val, index) => val === sortedNotifValue[index]);
      } else {
        return filterValue.includes(notifValue);
      }
    } else {
      return notifValue === filterValue;
    }
  });
}
function checkNotificationTagFilter(notificationTags, filterTags) {
  if (!filterTags || filterTags.length === 0) {
    return true;
  }
  if (!notificationTags || notificationTags.length === 0) {
    return false;
  }
  return filterTags.some((tag) => notificationTags.includes(tag));
}
function checkBasicFilters(notification, filter) {
  if (filter.read !== void 0 && notification.isRead !== filter.read) {
    return false;
  }
  if (filter.seen !== void 0 && notification.isSeen !== filter.seen) {
    return false;
  }
  if (filter.archived !== void 0 && notification.isArchived !== filter.archived) {
    return false;
  }
  if (filter.snoozed !== void 0 && notification.isSnoozed !== filter.snoozed) {
    return false;
  }
  return true;
}
function checkNotificationMatchesFilter(notification, filter) {
  return checkBasicFilters(notification, filter) && checkNotificationTagFilter(notification.tags, filter.tags) && checkNotificationDataFilter(notification.data, filter.data);
}

// src/subscriptions/subscription.ts
var _emitter, _inboxService, _cache, _useCache, _isStale;
var TopicSubscription = class {
  constructor(subscription, emitter, inboxService, cache, useCache) {
    __privateAdd(this, _emitter);
    __privateAdd(this, _inboxService);
    __privateAdd(this, _cache);
    __privateAdd(this, _useCache);
    __privateAdd(this, _isStale, false);
    var _a;
    __privateSet(this, _emitter, emitter);
    __privateSet(this, _inboxService, inboxService);
    __privateSet(this, _cache, cache);
    __privateSet(this, _useCache, useCache);
    this.id = subscription.id;
    this.identifier = subscription.identifier;
    this.topicKey = subscription.topicKey;
    this.preferences = (_a = subscription.preferences) == null ? void 0 : _a.map(
      (pref) => new SubscriptionPreference(__spreadValues({}, pref), __privateGet(this, _emitter), __privateGet(this, _inboxService), __privateGet(this, _cache), __privateGet(this, _useCache))
    );
  }
  update(args) {
    return __async(this, null, function* () {
      return updateSubscription({
        emitter: __privateGet(this, _emitter),
        apiService: __privateGet(this, _inboxService),
        cache: __privateGet(this, _cache),
        useCache: __privateGet(this, _useCache),
        args: __spreadProps(__spreadValues({}, args), { subscription: this })
      });
    });
  }
  updatePreference(args) {
    return __async(this, null, function* () {
      if (__privateGet(this, _isStale)) {
        return {
          error: new NovuError("Cannot update a deleted subscription", new Error("Subscription is stale"))
        };
      }
      return updateSubscriptionPreference({
        emitter: __privateGet(this, _emitter),
        apiService: __privateGet(this, _inboxService),
        cache: __privateGet(this, _cache),
        useCache: __privateGet(this, _useCache),
        args: __spreadProps(__spreadValues({}, args), { subscriptionId: this.identifier })
      });
    });
  }
  bulkUpdatePreferences(args) {
    return __async(this, null, function* () {
      if (__privateGet(this, _isStale)) {
        return {
          error: new NovuError("Cannot bulk update a deleted subscription", new Error("Subscription is stale"))
        };
      }
      return bulkUpdateSubscriptionPreference({
        emitter: __privateGet(this, _emitter),
        apiService: __privateGet(this, _inboxService),
        cache: __privateGet(this, _cache),
        useCache: __privateGet(this, _useCache),
        args: args.map((arg) => __spreadProps(__spreadValues({}, arg), { subscriptionId: this.identifier }))
      });
    });
  }
  delete() {
    return __async(this, null, function* () {
      if (__privateGet(this, _isStale)) {
        return {
          error: new NovuError("Cannot delete an already deleted subscription", new Error("Subscription is stale"))
        };
      }
      return deleteSubscription({
        emitter: __privateGet(this, _emitter),
        apiService: __privateGet(this, _inboxService),
        args: { subscription: this }
      });
    });
  }
};
_emitter = new WeakMap();
_inboxService = new WeakMap();
_cache = new WeakMap();
_useCache = new WeakMap();
_isStale = new WeakMap();

// src/subscriptions/helpers.ts
var listSubscriptions = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  options,
  args
}) {
  try {
    const { useCache, refetch } = options;
    let data = useCache && !refetch ? cache.getAll(args) : void 0;
    emitter.emit("subscriptions.list.pending", { args, data });
    if (!data || refetch) {
      const response = yield apiService.fetchSubscriptions(args.topicKey);
      data = response.map((el) => {
        return new TopicSubscription(__spreadProps(__spreadValues({}, el), { topicKey: args.topicKey }), emitter, apiService, cache, useCache);
      });
      if (useCache) {
        cache.set(args, data);
        data = cache.getAll(args);
      }
    }
    emitter.emit("subscriptions.list.resolved", { args, data });
    return { data };
  } catch (error) {
    emitter.emit("subscriptions.list.resolved", { args, error });
    return { error: new NovuError("Failed to fetch subscriptions", error) };
  }
});
var getSubscription = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  options,
  args
}) {
  try {
    const { useCache, refetch } = options;
    let data = useCache && !refetch ? cache.get(args) : void 0;
    emitter.emit("subscription.get.pending", { args, data });
    if (!data || refetch) {
      const response = yield apiService.getSubscription(args.topicKey, args.identifier, args.workflowIds, args.tags);
      if (!response) {
        emitter.emit("subscription.get.resolved", { args, data: null });
        return { data: null };
      }
      data = new TopicSubscription(__spreadProps(__spreadValues({}, response), { topicKey: args.topicKey }), emitter, apiService, cache, useCache);
      if (useCache) {
        cache.setOne(args, data);
        data = cache.get(args);
      }
    }
    emitter.emit("subscription.get.resolved", { args, data });
    return { data };
  } catch (error) {
    emitter.emit("subscription.get.resolved", { args, error });
    return { error: new NovuError("Failed to fetch subscription", error) };
  }
});
var createSubscription = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  useCache,
  args
}) {
  var _a;
  try {
    emitter.emit("subscription.create.pending", { args });
    const response = yield apiService.createSubscription({
      identifier: (_a = args.identifier) != null ? _a : "",
      name: args.name,
      topicKey: args.topicKey,
      topicName: args.topicName,
      preferences: args.preferences
    });
    const subscription = new TopicSubscription(
      __spreadProps(__spreadValues({}, response), { topicKey: args.topicKey }),
      emitter,
      apiService,
      cache,
      useCache
    );
    emitter.emit("subscription.create.resolved", { args, data: subscription });
    return { data: subscription };
  } catch (error) {
    emitter.emit("subscription.create.resolved", { args, error });
    return { error: new NovuError("Failed to create subscription", error) };
  }
});
var updateSubscription = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  useCache,
  args
}) {
  const identifier = "identifier" in args ? args.identifier : args.subscription.identifier;
  const topicKey = "topicKey" in args ? args.topicKey : args.subscription.topicKey;
  try {
    emitter.emit("subscription.update.pending", {
      args
    });
    const response = yield apiService.updateSubscription({
      topicKey,
      identifier,
      name: args.name,
      preferences: args.preferences
    });
    const updatedSubscription = new TopicSubscription(__spreadProps(__spreadValues({}, response), { topicKey }), emitter, apiService, cache, useCache);
    emitter.emit("subscription.update.resolved", { args, data: updatedSubscription });
    return { data: updatedSubscription };
  } catch (error) {
    emitter.emit("subscription.update.resolved", { args, error });
    return { error: new NovuError("Failed to update subscription", error) };
  }
});
var updateSubscriptionPreference = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  useCache,
  args
}) {
  var _a, _b;
  const workflowId = "workflowId" in args ? args.workflowId : (_b = (_a = args.preference) == null ? void 0 : _a.workflow) == null ? void 0 : _b.id;
  try {
    emitter.emit("subscription.preference.update.pending", {
      args,
      data: "preference" in args ? new SubscriptionPreference(
        __spreadValues(__spreadValues({}, args.preference), typeof args.value === "boolean" ? { enabled: args.value } : { condition: args.value }),
        emitter,
        apiService,
        cache,
        useCache
      ) : void 0
    });
    const response = yield apiService.updateSubscriptionPreference(__spreadValues({
      subscriptionIdentifier: args.subscriptionId,
      workflowId
    }, typeof args.value === "boolean" ? {
      enabled: args.value,
      email: args.value,
      sms: args.value,
      in_app: args.value,
      chat: args.value,
      push: args.value
    } : { condition: args.value }));
    const updatedSubscription = new SubscriptionPreference(__spreadValues({}, response), emitter, apiService, cache, useCache);
    emitter.emit("subscription.preference.update.resolved", { args, data: updatedSubscription });
    return { data: updatedSubscription };
  } catch (error) {
    emitter.emit("subscription.preference.update.resolved", { args, error });
    return { error: new NovuError("Failed to update subscription", error) };
  }
});
var bulkUpdateSubscriptionPreference = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  useCache,
  args
}) {
  try {
    const optimisticallyUpdatedPreferences = args.map(
      (arg) => "preference" in arg ? new SubscriptionPreference(
        __spreadValues(__spreadValues({}, arg.preference), typeof arg.value === "boolean" ? { enabled: arg.value } : { condition: arg.value }),
        emitter,
        apiService,
        cache,
        useCache
      ) : void 0
    ).filter((el) => el !== void 0);
    emitter.emit("subscription.preferences.bulk_update.pending", {
      args,
      data: optimisticallyUpdatedPreferences
    });
    const preferencesToUpdate = args.map((arg) => {
      var _a, _b, _c, _d, _e, _f;
      return __spreadValues({
        subscriptionIdentifier: arg.subscriptionId,
        workflowId: "workflowId" in arg ? arg.workflowId : (_f = (_e = (_b = (_a = arg.preference) == null ? void 0 : _a.workflow) == null ? void 0 : _b.id) != null ? _e : (_d = (_c = arg.preference) == null ? void 0 : _c.workflow) == null ? void 0 : _d.identifier) != null ? _f : ""
      }, typeof arg.value === "boolean" ? { enabled: arg.value, email: arg.value, sms: arg.value, in_app: arg.value, chat: arg.value, push: arg.value } : { condition: arg.value });
    });
    const response = yield apiService.bulkUpdateSubscriptionPreferences(preferencesToUpdate);
    const preferences = response.map((el) => new SubscriptionPreference(el, emitter, apiService, cache, useCache));
    emitter.emit("subscription.preferences.bulk_update.resolved", { args, data: preferences });
    return { data: preferences };
  } catch (error) {
    emitter.emit("subscription.preferences.bulk_update.resolved", { args, error });
    return { error: new NovuError("Failed to bulk update subscription preferences", error) };
  }
});
var deleteSubscription = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const identifier = "identifier" in args ? args.identifier : args.subscription.identifier;
  const topicKey = "topicKey" in args ? args.topicKey : args.subscription.topicKey;
  try {
    emitter.emit("subscription.delete.pending", { args });
    yield apiService.deleteSubscription({ topicKey, identifier });
    emitter.emit("subscription.delete.resolved", { args });
    return { data: void 0 };
  } catch (error) {
    emitter.emit("subscription.delete.resolved", { args, error });
    return { error: new NovuError("Failed to delete subscription", error) };
  }
});

// src/subscriptions/subscription-preference.ts
var _emitter2, _inboxService2, _cache2, _useCache2;
var SubscriptionPreference = class {
  constructor(preference, emitter, inboxService, cache, useCache) {
    __privateAdd(this, _emitter2);
    __privateAdd(this, _inboxService2);
    __privateAdd(this, _cache2);
    __privateAdd(this, _useCache2);
    var _a;
    __privateSet(this, _emitter2, emitter);
    __privateSet(this, _inboxService2, inboxService);
    __privateSet(this, _cache2, cache);
    __privateSet(this, _useCache2, useCache);
    this.enabled = preference.enabled;
    this.condition = (_a = preference.condition) != null ? _a : void 0;
    this.workflow = preference.workflow;
    this.subscriptionId = preference.subscriptionId;
  }
  update(args) {
    return __async(this, null, function* () {
      var _a;
      return updateSubscriptionPreference({
        emitter: __privateGet(this, _emitter2),
        apiService: __privateGet(this, _inboxService2),
        cache: __privateGet(this, _cache2),
        useCache: __privateGet(this, _useCache2),
        args: {
          subscriptionId: this.subscriptionId,
          workflowId: (_a = this.workflow) == null ? void 0 : _a.id,
          value: args.value,
          preference: this
        }
      });
    });
  }
};
_emitter2 = new WeakMap();
_inboxService2 = new WeakMap();
_cache2 = new WeakMap();
_useCache2 = new WeakMap();

// src/base-module.ts
var _callsQueue, _sessionError;
var BaseModule = class {
  constructor({
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    __privateAdd(this, _callsQueue, []);
    __privateAdd(this, _sessionError);
    this._emitter = eventEmitterInstance;
    this._inboxService = inboxServiceInstance;
    this._emitter.on("session.initialize.resolved", ({ error, data }) => {
      if (data) {
        this.onSessionSuccess(data);
        __privateGet(this, _callsQueue).forEach((_0) => __async(this, [_0], function* ({ fn, resolve }) {
          resolve(yield fn());
        }));
        __privateSet(this, _callsQueue, []);
      } else if (error) {
        this.onSessionError(error);
        __privateSet(this, _sessionError, error);
        __privateGet(this, _callsQueue).forEach(({ resolve }) => {
          resolve({ error: new NovuError("Failed to initialize session, please contact the support", error) });
        });
        __privateSet(this, _callsQueue, []);
      }
    });
  }
  onSessionSuccess(_) {
  }
  onSessionError(_) {
  }
  callWithSession(fn) {
    return __async(this, null, function* () {
      if (this._inboxService.isSessionInitialized) {
        return fn();
      }
      if (__privateGet(this, _sessionError)) {
        return Promise.resolve({
          error: new NovuError("Failed to initialize session, please contact the support", __privateGet(this, _sessionError))
        });
      }
      return new Promise((resolve, reject) => {
        __privateGet(this, _callsQueue).push({ fn, resolve, reject });
      });
    });
  }
};
_callsQueue = new WeakMap();
_sessionError = new WeakMap();

// src/cache/in-memory-cache.ts
var _cache3;
var InMemoryCache = class {
  constructor() {
    __privateAdd(this, _cache3);
    __privateSet(this, _cache3, /* @__PURE__ */ new Map());
  }
  get(key) {
    return __privateGet(this, _cache3).get(key);
  }
  getValues() {
    return Array.from(__privateGet(this, _cache3).values());
  }
  entries() {
    return Array.from(__privateGet(this, _cache3).entries());
  }
  keys() {
    return Array.from(__privateGet(this, _cache3).keys());
  }
  set(key, value) {
    __privateGet(this, _cache3).set(key, value);
  }
  remove(key) {
    __privateGet(this, _cache3).delete(key);
  }
  clear() {
    __privateGet(this, _cache3).clear();
  }
};
_cache3 = new WeakMap();

// src/cache/subscriptions-cache.ts
var getListCacheKey = (args) => {
  return `list:${args.topicKey}`;
};
var getTopicKeyFromListCacheKey = (key) => {
  return key.split(":")[1];
};
var getItemCacheKey = (args) => {
  return `item:${args.topicKey}:${args.identifier}`;
};
var _emitter3, _cache4, _useCache3, _itemCache, _inboxService3;
var SubscriptionsCache = class {
  constructor({
    emitterInstance,
    inboxServiceInstance,
    useCache
  }) {
    __privateAdd(this, _emitter3);
    __privateAdd(this, _cache4);
    __privateAdd(this, _useCache3);
    __privateAdd(this, _itemCache);
    __privateAdd(this, _inboxService3);
    this.handleCreate = (subscription) => {
      const listKey = getListCacheKey({ topicKey: subscription.topicKey });
      const subscriptions = __privateGet(this, _cache4).get(listKey);
      if (subscriptions) {
        const updatedSubscriptions = [...subscriptions, subscription];
        __privateGet(this, _cache4).set(listKey, updatedSubscriptions);
        __privateGet(this, _emitter3).emit("subscriptions.list.updated", {
          data: { topicKey: subscription.topicKey, subscriptions: updatedSubscriptions }
        });
      }
      __privateGet(this, _itemCache).set(
        getItemCacheKey({ topicKey: subscription.topicKey, identifier: subscription.identifier }),
        subscription
      );
    };
    this.handleUpdate = (subscription) => {
      const listKey = getListCacheKey({ topicKey: subscription.topicKey });
      const subscriptions = __privateGet(this, _cache4).get(listKey);
      if (subscriptions) {
        const updatedSubscriptions = subscriptions.map((el) => el.id === subscription.id ? subscription : el);
        __privateGet(this, _cache4).set(listKey, updatedSubscriptions);
        __privateGet(this, _emitter3).emit("subscriptions.list.updated", {
          data: { topicKey: subscription.topicKey, subscriptions: updatedSubscriptions }
        });
      }
      __privateGet(this, _itemCache).set(
        getItemCacheKey({ topicKey: subscription.topicKey, identifier: subscription.identifier }),
        subscription
      );
    };
    this.handlePreferenceUpdate = (preference) => {
      this.updateSubscriptionPreferences([preference]);
    };
    this.handleBulkPreferenceUpdate = (preferences) => {
      this.updateSubscriptionPreferences(preferences);
    };
    this.updateSubscriptionPreferences = (updatedPreferences) => {
      var _a;
      const preferencesBySubscription = /* @__PURE__ */ new Map();
      for (const pref of updatedPreferences) {
        const existing = (_a = preferencesBySubscription.get(pref.subscriptionId)) != null ? _a : [];
        existing.push(pref);
        preferencesBySubscription.set(pref.subscriptionId, existing);
      }
      const allListKeys = __privateGet(this, _cache4).keys();
      for (const listKey of allListKeys) {
        const subscriptions = __privateGet(this, _cache4).get(listKey);
        if (!subscriptions) continue;
        let hasUpdates = false;
        const updatedSubscriptions = subscriptions.map((subscription) => {
          const subscriptionPreferences = preferencesBySubscription.get(subscription.id);
          if (subscriptionPreferences) {
            hasUpdates = true;
            return this.createUpdatedSubscription(subscription, subscriptionPreferences);
          }
          return subscription;
        });
        if (hasUpdates) {
          __privateGet(this, _cache4).set(listKey, updatedSubscriptions);
          __privateGet(this, _emitter3).emit("subscriptions.list.updated", {
            data: { topicKey: getTopicKeyFromListCacheKey(listKey), subscriptions: updatedSubscriptions }
          });
        }
      }
      const allItemKeys = __privateGet(this, _itemCache).keys();
      for (const key of allItemKeys) {
        const subscription = __privateGet(this, _itemCache).get(key);
        if (!subscription) continue;
        const subscriptionPreferences = preferencesBySubscription.get(subscription.id);
        if (subscriptionPreferences) {
          const updatedSubscription = this.createUpdatedSubscription(subscription, subscriptionPreferences);
          __privateGet(this, _itemCache).set(key, updatedSubscription);
          __privateGet(this, _emitter3).emit("subscription.update.resolved", {
            args: { subscription },
            data: updatedSubscription
          });
        }
      }
    };
    this.createUpdatedSubscription = (subscription, subscriptionPreferences) => {
      var _a;
      const updatedPreferences = (_a = subscription.preferences) == null ? void 0 : _a.map((pref) => {
        const newPreference = subscriptionPreferences.find((el) => el.workflow.id === pref.workflow.id);
        if (newPreference) {
          return newPreference;
        }
        return pref;
      });
      return new TopicSubscription(
        {
          id: subscription.id,
          identifier: subscription.identifier,
          topicKey: subscription.topicKey,
          preferences: updatedPreferences
        },
        __privateGet(this, _emitter3),
        __privateGet(this, _inboxService3),
        this,
        __privateGet(this, _useCache3)
      );
    };
    this.handleDelete = (subscription) => {
      const listKey = getListCacheKey({ topicKey: subscription.topicKey });
      const subscriptions = __privateGet(this, _cache4).get(listKey);
      if (subscriptions) {
        const updatedSubscriptions = subscriptions.filter((el) => el.id !== subscription.id);
        __privateGet(this, _cache4).set(listKey, updatedSubscriptions);
        __privateGet(this, _emitter3).emit("subscriptions.list.updated", {
          data: { topicKey: subscription.topicKey, subscriptions: updatedSubscriptions }
        });
      }
      __privateGet(this, _itemCache).remove(getItemCacheKey({ topicKey: subscription.topicKey, identifier: subscription.identifier }));
    };
    this.handleDeleteByIdentifier = (identifier) => {
      const allListKeys = __privateGet(this, _cache4).keys();
      for (const listKey of allListKeys) {
        const subscriptions = __privateGet(this, _cache4).get(listKey);
        if (subscriptions) {
          const subscription = subscriptions.find((el) => el.identifier === identifier);
          if (subscription) {
            const updatedSubscriptions = subscriptions.filter((el) => el.identifier !== identifier);
            __privateGet(this, _cache4).set(listKey, updatedSubscriptions);
            __privateGet(this, _emitter3).emit("subscriptions.list.updated", {
              data: { topicKey: getTopicKeyFromListCacheKey(listKey), subscriptions: updatedSubscriptions }
            });
            __privateGet(this, _itemCache).remove(
              getItemCacheKey({ topicKey: subscription.topicKey, identifier: subscription.identifier })
            );
            return;
          }
        }
      }
      const allItemKeys = __privateGet(this, _itemCache).keys();
      for (const key of allItemKeys) {
        const subscription = __privateGet(this, _itemCache).get(key);
        if (subscription && subscription.identifier === identifier) {
          __privateGet(this, _itemCache).remove(key);
          return;
        }
      }
    };
    __privateSet(this, _emitter3, emitterInstance);
    __privateSet(this, _cache4, new InMemoryCache());
    __privateSet(this, _itemCache, new InMemoryCache());
    __privateSet(this, _inboxService3, inboxServiceInstance);
    __privateSet(this, _useCache3, useCache);
    __privateGet(this, _emitter3).on("subscription.create.resolved", ({ data }) => {
      if (data) {
        this.handleCreate(data);
      }
    });
    __privateGet(this, _emitter3).on("subscription.update.resolved", ({ data }) => {
      if (data) {
        this.handleUpdate(data);
      }
    });
    __privateGet(this, _emitter3).on("subscription.delete.resolved", ({ args }) => {
      if ("subscription" in args) {
        this.handleDelete(args.subscription);
      } else if ("identifier" in args) {
        this.handleDeleteByIdentifier(args.identifier);
      }
    });
    __privateGet(this, _emitter3).on("subscription.preference.update.pending", ({ data }) => {
      if (data) {
        this.handlePreferenceUpdate(data);
      }
    });
    __privateGet(this, _emitter3).on("subscription.preference.update.resolved", ({ data }) => {
      if (data) {
        this.handlePreferenceUpdate(data);
      }
    });
    __privateGet(this, _emitter3).on("subscription.preferences.bulk_update.resolved", ({ data }) => {
      if (data && data.length > 0) {
        this.handleBulkPreferenceUpdate(data);
      }
    });
  }
  has(args) {
    return __privateGet(this, _cache4).get(getListCacheKey(args)) !== void 0;
  }
  set(args, data) {
    __privateGet(this, _cache4).set(getListCacheKey(args), data);
    for (const subscription of data) {
      __privateGet(this, _itemCache).set(
        getItemCacheKey({ topicKey: args.topicKey, identifier: subscription.identifier }),
        subscription
      );
    }
  }
  setOne(args, data) {
    __privateGet(this, _itemCache).set(getItemCacheKey(args), data);
  }
  getAll(args) {
    return __privateGet(this, _cache4).get(getListCacheKey(args));
  }
  get(args) {
    return __privateGet(this, _itemCache).get(getItemCacheKey(args));
  }
  invalidate(args) {
    const listKey = getListCacheKey({ topicKey: args.topicKey });
    const subscriptions = __privateGet(this, _cache4).get(listKey);
    if (subscriptions) {
      for (const subscription of subscriptions) {
        __privateGet(this, _itemCache).remove(getItemCacheKey({ topicKey: args.topicKey, identifier: subscription.identifier }));
      }
    }
    __privateGet(this, _cache4).remove(listKey);
    const allItemKeys = __privateGet(this, _itemCache).keys();
    for (const key of allItemKeys) {
      if (key.startsWith(`item:${args.topicKey}:`)) {
        __privateGet(this, _itemCache).remove(key);
      }
    }
  }
  clearAll() {
    __privateGet(this, _cache4).clear();
    __privateGet(this, _itemCache).clear();
  }
};
_emitter3 = new WeakMap();
_cache4 = new WeakMap();
_useCache3 = new WeakMap();
_itemCache = new WeakMap();
_inboxService3 = new WeakMap();

// src/subscriptions/subscriptions.ts
var _useCache4, _subscriber, _contextKey;
var Subscriptions = class extends BaseModule {
  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance,
    subscriber,
    contextKey
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache4);
    __privateAdd(this, _subscriber);
    __privateAdd(this, _contextKey);
    this.cache = new SubscriptionsCache({
      emitterInstance: this._emitter,
      inboxServiceInstance: this._inboxService,
      useCache
    });
    __privateSet(this, _useCache4, useCache);
    __privateSet(this, _subscriber, subscriber);
    __privateSet(this, _contextKey, contextKey);
  }
  list(args, options) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => {
          var _a;
          return listSubscriptions({
            emitter: this._emitter,
            apiService: this._inboxService,
            cache: this.cache,
            options: __spreadProps(__spreadValues({}, options), {
              useCache: (_a = options == null ? void 0 : options.useCache) != null ? _a : __privateGet(this, _useCache4)
            }),
            args
          });
        }
      );
    });
  }
  get(args, options) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => {
          var _a, _b;
          return getSubscription({
            emitter: this._emitter,
            apiService: this._inboxService,
            cache: this.cache,
            options: __spreadProps(__spreadValues({}, options), {
              useCache: (_a = options == null ? void 0 : options.useCache) != null ? _a : __privateGet(this, _useCache4)
            }),
            args: __spreadProps(__spreadValues({}, args), {
              identifier: (_b = args.identifier) != null ? _b : buildSubscriptionIdentifier({
                topicKey: args.topicKey,
                subscriberId: __privateGet(this, _subscriber).subscriberId,
                contextKey: __privateGet(this, _contextKey)
              })
            })
          });
        }
      );
    });
  }
  create(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => createSubscription({
          emitter: this._emitter,
          apiService: this._inboxService,
          cache: this.cache,
          useCache: __privateGet(this, _useCache4),
          args
        })
      );
    });
  }
  update(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => updateSubscription({
          emitter: this._emitter,
          apiService: this._inboxService,
          cache: this.cache,
          useCache: __privateGet(this, _useCache4),
          args
        })
      );
    });
  }
  delete(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => deleteSubscription({
          emitter: this._emitter,
          apiService: this._inboxService,
          args
        })
      );
    });
  }
};
_useCache4 = new WeakMap();
_subscriber = new WeakMap();
_contextKey = new WeakMap();

// src/api/http-client.ts
var DEFAULT_API_VERSION = "v1";
var DEFAULT_CLIENT_VERSION = `${"@novu/js"}@${"3.13.0"}`;
var HttpClient = class {
  constructor(options = {}) {
    // Environment variable for local development that overrides the default API endpoint without affecting the Inbox DX
    this.DEFAULT_BACKEND_URL = typeof window !== "undefined" && window.NOVU_LOCAL_BACKEND_URL || "https://api.novu.co";
    const {
      apiVersion = DEFAULT_API_VERSION,
      apiUrl = this.DEFAULT_BACKEND_URL,
      userAgent = DEFAULT_CLIENT_VERSION,
      headers = {}
    } = options || {};
    this.apiVersion = apiVersion;
    this.apiUrl = `${apiUrl}/${apiVersion}`;
    this.headers = __spreadValues({
      "Novu-API-Version": "2024-06-26",
      "Novu-Client-Version": DEFAULT_CLIENT_VERSION,
      "Content-Type": "application/json",
      "User-Agent": userAgent
    }, headers);
  }
  setAuthorizationToken(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  setKeylessHeader(identifier) {
    var _a;
    const keylessAppIdentifier = identifier || typeof window !== "undefined" && ((_a = window.localStorage) == null ? void 0 : _a.getItem("novu_keyless_application_identifier"));
    if (!keylessAppIdentifier || !keylessAppIdentifier.startsWith("pk_keyless_")) {
      return;
    }
    this.headers["Novu-Application-Identifier"] = keylessAppIdentifier;
  }
  setHeaders(headers) {
    this.headers = __spreadValues(__spreadValues({}, this.headers), headers);
  }
  get(path, searchParams, unwrapEnvelope = true) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        searchParams,
        options: {
          method: "GET"
        },
        unwrapEnvelope
      });
    });
  }
  post(path, body, options) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "POST",
          body,
          headers: options == null ? void 0 : options.headers
        }
      });
    });
  }
  patch(path, body) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "PATCH",
          body
        }
      });
    });
  }
  delete(path, body) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "DELETE",
          body
        }
      });
    });
  }
  doFetch(_0) {
    return __async(this, arguments, function* ({
      path,
      searchParams,
      options,
      unwrapEnvelope = true
    }) {
      const fullUrl = combineUrl(this.apiUrl, path, searchParams ? `?${searchParams.toString()}` : "");
      const reqInit = {
        method: (options == null ? void 0 : options.method) || "GET",
        headers: __spreadValues(__spreadValues({}, this.headers), (options == null ? void 0 : options.headers) || {}),
        body: (options == null ? void 0 : options.body) ? JSON.stringify(options.body) : void 0
      };
      const response = yield fetch(fullUrl, reqInit);
      if (!response.ok) {
        const errorData = yield response.json();
        throw new Error(
          `${this.headers["Novu-Client-Version"]} error. Status: ${response.status}, Message: ${errorData.message}`
        );
      }
      if (response.status === 204) {
        return void 0;
      }
      const res = yield response.json();
      return unwrapEnvelope ? res.data : res;
    });
  }
};
function combineUrl(...args) {
  return args.reduce((acc, part) => {
    if (part) {
      acc.push(part.replace(new RegExp("(?<!https?:)\\/+", "g"), "/").replace(/^\/+|\/+$/g, ""));
    }
    return acc;
  }, []).join("/").replace(/\/\?/, "?");
}

// src/api/inbox-service.ts
var INBOX_ROUTE = "/inbox";
var INBOX_NOTIFICATIONS_ROUTE = `${INBOX_ROUTE}/notifications`;
var _httpClient;
var InboxService = class {
  constructor(options = {}) {
    this.isSessionInitialized = false;
    __privateAdd(this, _httpClient);
    __privateSet(this, _httpClient, new HttpClient(options));
  }
  initializeSession(_0) {
    return __async(this, arguments, function* ({
      applicationIdentifier,
      subscriberHash,
      contextHash,
      subscriber,
      defaultSchedule,
      context
    }) {
      const response = yield __privateGet(this, _httpClient).post(`${INBOX_ROUTE}/session`, {
        applicationIdentifier,
        subscriberHash,
        contextHash,
        subscriber,
        defaultSchedule,
        context
      });
      __privateGet(this, _httpClient).setAuthorizationToken(response.token);
      __privateGet(this, _httpClient).setKeylessHeader(response.applicationIdentifier);
      this.isSessionInitialized = true;
      return response;
    });
  }
  fetchNotifications({
    after,
    archived,
    limit = 10,
    offset,
    read: read2,
    tags,
    snoozed,
    seen: seen2,
    data,
    severity
  }) {
    const searchParams = new URLSearchParams(`limit=${limit}`);
    if (after) {
      searchParams.append("after", after);
    }
    if (offset) {
      searchParams.append("offset", `${offset}`);
    }
    if (tags) {
      for (const tag of tags) {
        searchParams.append("tags[]", tag);
      }
    }
    if (read2 !== void 0) {
      searchParams.append("read", `${read2}`);
    }
    if (archived !== void 0) {
      searchParams.append("archived", `${archived}`);
    }
    if (snoozed !== void 0) {
      searchParams.append("snoozed", `${snoozed}`);
    }
    if (seen2 !== void 0) {
      searchParams.append("seen", `${seen2}`);
    }
    if (data !== void 0) {
      searchParams.append("data", JSON.stringify(data));
    }
    if (severity && Array.isArray(severity)) {
      for (const el of severity) {
        searchParams.append("severity[]", el);
      }
    } else if (severity) {
      searchParams.append("severity", severity);
    }
    return __privateGet(this, _httpClient).get(INBOX_NOTIFICATIONS_ROUTE, searchParams, false);
  }
  count({
    filters
  }) {
    return __privateGet(this, _httpClient).get(
      `${INBOX_NOTIFICATIONS_ROUTE}/count`,
      new URLSearchParams({
        filters: JSON.stringify(filters)
      }),
      false
    );
  }
  read(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/read`);
  }
  unread(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unread`);
  }
  archive(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/archive`);
  }
  unarchive(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unarchive`);
  }
  snooze(notificationId, snoozeUntil) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/snooze`, { snoozeUntil });
  }
  unsnooze(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unsnooze`);
  }
  readAll({ tags, data }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/read`, {
      tags,
      data: data ? JSON.stringify(data) : void 0
    });
  }
  archiveAll({ tags, data }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/archive`, {
      tags,
      data: data ? JSON.stringify(data) : void 0
    });
  }
  archiveAllRead({ tags, data }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/read-archive`, {
      tags,
      data: data ? JSON.stringify(data) : void 0
    });
  }
  delete(notificationId) {
    return __privateGet(this, _httpClient).delete(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/delete`);
  }
  deleteAll({ tags, data }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/delete`, {
      tags,
      data: data ? JSON.stringify(data) : void 0
    });
  }
  markAsSeen({
    notificationIds,
    tags,
    data
  }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/seen`, {
      notificationIds,
      tags,
      data: data ? JSON.stringify(data) : void 0
    });
  }
  seen(notificationId) {
    return this.markAsSeen({ notificationIds: [notificationId] });
  }
  completeAction({
    actionType,
    notificationId
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/complete`, {
      actionType
    });
  }
  revertAction({
    actionType,
    notificationId
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/revert`, {
      actionType
    });
  }
  fetchPreferences({
    tags,
    severity,
    criticality
  }) {
    const queryParams = new URLSearchParams();
    if (tags) {
      for (const tag of tags) {
        queryParams.append("tags[]", tag);
      }
    }
    if (severity && Array.isArray(severity)) {
      for (const el of severity) {
        queryParams.append("severity[]", el);
      }
    } else if (severity) {
      queryParams.append("severity", severity);
    }
    if (criticality) {
      queryParams.append("criticality", criticality);
    }
    const query = queryParams.size ? `?${queryParams.toString()}` : "";
    return __privateGet(this, _httpClient).get(`${INBOX_ROUTE}/preferences${query}`);
  }
  bulkUpdatePreferences(preferences) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences/bulk`, { preferences });
  }
  updateGlobalPreferences(preferences) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences`, preferences);
  }
  updateWorkflowPreferences({
    workflowId,
    channels
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences/${workflowId}`, channels);
  }
  fetchGlobalPreferences() {
    return __privateGet(this, _httpClient).get(`${INBOX_ROUTE}/preferences/global`);
  }
  triggerHelloWorldEvent() {
    const payload = {
      name: "hello-world",
      to: {
        subscriberId: "keyless-subscriber-id"
      },
      payload: {
        subject: "Novu Keyless Environment",
        body: "You're using a keyless demo environment. For full access to Novu features and cloud integration, obtain your API key.",
        primaryActionText: "Obtain API Key",
        primaryActionUrl: "https://go.novu.co/keyless",
        secondaryActionText: "Explore Documentation",
        secondaryActionUrl: "https://go.novu.co/keyless-docs"
      }
    };
    return __privateGet(this, _httpClient).post("/inbox/events", payload);
  }
  fetchSubscriptions(topicKey) {
    return __privateGet(this, _httpClient).get(`${INBOX_ROUTE}/topics/${topicKey}/subscriptions`);
  }
  getSubscription(topicKey, identifier, workflowIds, tags) {
    const searchParams = new URLSearchParams();
    if (workflowIds == null ? void 0 : workflowIds.length)
      for (const workflowIdentifier of workflowIds) searchParams.append("workflowIds", workflowIdentifier);
    if (tags == null ? void 0 : tags.length) for (const tag of tags) searchParams.append("tags", tag);
    const query = searchParams.size ? `?${searchParams.toString()}` : "";
    return __privateGet(this, _httpClient).get(`${INBOX_ROUTE}/topics/${topicKey}/subscriptions/${identifier}${query}`);
  }
  createSubscription({
    identifier,
    name,
    topicKey,
    topicName,
    preferences
  }) {
    return __privateGet(this, _httpClient).post(`${INBOX_ROUTE}/topics/${topicKey}/subscriptions`, __spreadValues(__spreadValues({
      identifier,
      name
    }, topicName && { topic: { name: topicName } }), preferences !== void 0 && { preferences }));
  }
  updateSubscription({
    topicKey,
    identifier,
    name,
    preferences
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/topics/${topicKey}/subscriptions/${identifier}`, __spreadValues({
      name
    }, preferences !== void 0 && { preferences }));
  }
  updateSubscriptionPreference({
    subscriptionIdentifier,
    workflowId,
    enabled,
    condition,
    email,
    sms,
    in_app,
    chat,
    push
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/subscriptions/${subscriptionIdentifier}/preferences/${workflowId}`, {
      enabled,
      condition,
      email,
      sms,
      in_app,
      chat,
      push
    });
  }
  bulkUpdateSubscriptionPreferences(preferences) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences/bulk`, { preferences });
  }
  deleteSubscription({ topicKey, identifier }) {
    return __privateGet(this, _httpClient).delete(`${INBOX_ROUTE}/topics/${topicKey}/subscriptions/${identifier}`);
  }
};
_httpClient = new WeakMap();
var _mittEmitter;
var NovuEventEmitter = class {
  constructor() {
    __privateAdd(this, _mittEmitter);
    __privateSet(this, _mittEmitter, mitt());
  }
  on(eventName, listener) {
    __privateGet(this, _mittEmitter).on(eventName, listener);
    return () => {
      this.off(eventName, listener);
    };
  }
  off(eventName, listener) {
    __privateGet(this, _mittEmitter).off(eventName, listener);
  }
  emit(type, event) {
    __privateGet(this, _mittEmitter).emit(type, event);
  }
};
_mittEmitter = new WeakMap();

// src/cache/notifications-cache.ts
var excludeEmpty = ({
  tags,
  data,
  read: read2,
  archived,
  snoozed,
  seen: seen2,
  severity,
  limit,
  offset,
  after
}) => Object.entries({ tags, data, read: read2, archived, snoozed, seen: seen2, severity, limit, offset, after }).filter(([_, value]) => value !== null && value !== void 0 && !(Array.isArray(value) && value.length === 0)).reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
var getCacheKey = ({
  tags,
  data,
  read: read2,
  archived,
  snoozed,
  seen: seen2,
  severity,
  limit,
  offset,
  after
}) => {
  return JSON.stringify(excludeEmpty({ tags, data, read: read2, archived, snoozed, seen: seen2, severity, limit, offset, after }));
};
var getFilterKey = ({
  tags,
  data,
  read: read2,
  archived,
  snoozed,
  seen: seen2,
  severity
}) => {
  return JSON.stringify(excludeEmpty({ tags, data, read: read2, archived, snoozed, seen: seen2, severity }));
};
var getFilter = (key) => {
  return JSON.parse(key);
};
var updateEvents = [
  "notification.read.pending",
  "notification.read.resolved",
  "notification.unread.pending",
  "notification.unread.resolved",
  "notification.complete_action.pending",
  "notification.complete_action.resolved",
  "notification.revert_action.pending",
  "notification.revert_action.resolved",
  "notifications.read_all.pending",
  "notifications.read_all.resolved"
];
var removeEvents = [
  "notification.archive.pending",
  "notification.unarchive.pending",
  "notification.snooze.pending",
  "notification.unsnooze.pending",
  "notification.delete.pending",
  "notifications.archive_all.pending",
  "notifications.archive_all_read.pending",
  "notifications.delete_all.pending"
];
var _emitter4, _inboxService4, _cache5;
var NotificationsCache = class {
  constructor({ emitter, inboxService }) {
    __privateAdd(this, _emitter4);
    __privateAdd(this, _inboxService4);
    /**
     * The key is the stringified notifications filter, the values are the paginated notifications.
     */
    __privateAdd(this, _cache5);
    this.updateNotification = (key, data) => {
      const notificationsResponse = __privateGet(this, _cache5).get(key);
      if (!notificationsResponse) {
        return false;
      }
      const index = notificationsResponse.notifications.findIndex((el) => el.id === data.id);
      if (index === -1) {
        return false;
      }
      const updatedNotifications = [...notificationsResponse.notifications];
      updatedNotifications[index] = data;
      __privateGet(this, _cache5).set(key, __spreadProps(__spreadValues({}, notificationsResponse), { notifications: updatedNotifications }));
      return true;
    };
    this.removeNotification = (key, data) => {
      const notificationsResponse = __privateGet(this, _cache5).get(key);
      if (!notificationsResponse) {
        return false;
      }
      const index = notificationsResponse.notifications.findIndex((el) => el.id === data.id);
      if (index === -1) {
        return false;
      }
      const newNotifications = [...notificationsResponse.notifications];
      newNotifications.splice(index, 1);
      __privateGet(this, _cache5).set(key, __spreadProps(__spreadValues({}, notificationsResponse), {
        notifications: newNotifications
      }));
      return true;
    };
    this.handleNotificationEvent = ({ remove } = { remove: false }) => (event) => {
      const { data, args } = event;
      let notifications = [];
      if (data !== void 0 && data !== null) {
        if (Array.isArray(data) && data.every((item) => typeof item === "object" && "id" in item)) {
          notifications = data;
        } else if (typeof data === "object" && "id" in data) {
          notifications = [data];
        }
      } else if (remove && args) {
        if ("notification" in args && args.notification) {
          notifications = [args.notification];
        } else if ("notificationId" in args && args.notificationId) {
          const foundNotifications = [];
          __privateGet(this, _cache5).keys().forEach((key) => {
            const cachedResponse = __privateGet(this, _cache5).get(key);
            if (cachedResponse) {
              const found = cachedResponse.notifications.find((n) => n.id === args.notificationId);
              if (found) {
                foundNotifications.push(found);
              }
            }
          });
          notifications = foundNotifications;
        }
      }
      if (notifications.length === 0) {
        return;
      }
      const uniqueFilterKeys = /* @__PURE__ */ new Set();
      __privateGet(this, _cache5).keys().forEach((key) => {
        notifications.forEach((notification) => {
          let isNotificationFound = false;
          if (remove) {
            isNotificationFound = this.removeNotification(key, notification);
          } else {
            isNotificationFound = this.updateNotification(key, notification);
          }
          if (isNotificationFound) {
            uniqueFilterKeys.add(getFilterKey(getFilter(key)));
          }
        });
      });
      uniqueFilterKeys.forEach((key) => {
        const notificationsResponse = this.getAggregated(getFilter(key));
        __privateGet(this, _emitter4).emit("notifications.list.updated", {
          data: notificationsResponse
        });
      });
    };
    __privateSet(this, _emitter4, emitter);
    __privateSet(this, _inboxService4, inboxService);
    updateEvents.forEach((event) => {
      __privateGet(this, _emitter4).on(event, this.handleNotificationEvent());
    });
    removeEvents.forEach((event) => {
      __privateGet(this, _emitter4).on(event, this.handleNotificationEvent({ remove: true }));
    });
    __privateSet(this, _cache5, new InMemoryCache());
  }
  getAggregated(filter) {
    const cacheKeys = __privateGet(this, _cache5).keys().filter((key) => {
      const parsedFilter = getFilter(key);
      return isSameFilter(parsedFilter, filter);
    });
    return cacheKeys.map((key) => __privateGet(this, _cache5).get(key)).reduce(
      (acc, el) => {
        if (!el) {
          return acc;
        }
        return {
          hasMore: el.hasMore,
          filter: el.filter,
          notifications: [...acc.notifications, ...el.notifications]
        };
      },
      { hasMore: false, filter: {}, notifications: [] }
    );
  }
  get(args) {
    return __privateGet(this, _cache5).get(getCacheKey(args));
  }
  has(args) {
    return __privateGet(this, _cache5).get(getCacheKey(args)) !== void 0;
  }
  set(args, data) {
    __privateGet(this, _cache5).set(getCacheKey(args), data);
  }
  unshift(args, notification) {
    const cacheKey = getCacheKey(args);
    const cachedData = __privateGet(this, _cache5).get(cacheKey) || {
      hasMore: false,
      filter: getFilter(cacheKey),
      notifications: []
    };
    const notificationInstance = createNotification({
      notification: __spreadValues({}, notification),
      emitter: __privateGet(this, _emitter4),
      inboxService: __privateGet(this, _inboxService4)
    });
    this.update(args, __spreadProps(__spreadValues({}, cachedData), {
      notifications: [notificationInstance, ...cachedData.notifications]
    }));
  }
  update(args, data) {
    this.set(args, data);
    const notificationsResponse = this.getAggregated(getFilter(getCacheKey(args)));
    __privateGet(this, _emitter4).emit("notifications.list.updated", {
      data: notificationsResponse
    });
  }
  getAll(args) {
    if (this.has(args)) {
      return this.getAggregated({
        tags: args.tags,
        data: args.data,
        read: args.read,
        snoozed: args.snoozed,
        archived: args.archived,
        seen: args.seen,
        severity: args.severity
      });
    }
  }
  /**
   * Get unique notifications based on specified filter fields.
   * The same tags and data can be applied to multiple filters which means that the same notification can be duplicated.
   */
  getUniqueNotifications({
    tags,
    read: read2,
    data
  }) {
    const keys = __privateGet(this, _cache5).keys();
    const uniqueNotifications = /* @__PURE__ */ new Map();
    keys.forEach((key) => {
      const filter = getFilter(key);
      if (areTagsEqual(tags, filter.tags) && areDataEqual(data, filter.data)) {
        const value = __privateGet(this, _cache5).get(key);
        if (!value) {
          return;
        }
        value.notifications.filter((el) => typeof read2 === "undefined" || read2 === el.isRead).forEach((notification) => {
          uniqueNotifications.set(notification.id, notification);
        });
      }
    });
    return Array.from(uniqueNotifications.values());
  }
  clear(filter) {
    const keys = __privateGet(this, _cache5).keys();
    keys.forEach((key) => {
      if (isSameFilter(getFilter(key), filter)) {
        __privateGet(this, _cache5).remove(key);
      }
    });
  }
  clearAll() {
    __privateGet(this, _cache5).clear();
  }
};
_emitter4 = new WeakMap();
_inboxService4 = new WeakMap();
_cache5 = new WeakMap();

// src/notifications/notifications.ts
var _useCache5;
var Notifications = class extends BaseModule {
  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache5);
    this.cache = new NotificationsCache({
      emitter: eventEmitterInstance,
      inboxService: inboxServiceInstance
    });
    __privateSet(this, _useCache5, useCache);
  }
  list() {
    return __async(this, arguments, function* (_a = {}) {
      var _b = _a, { limit = 10 } = _b, restOptions = __objRest(_b, ["limit"]);
      return this.callWithSession(() => __async(this, null, function* () {
        const args = __spreadValues({ limit }, restOptions);
        try {
          const shouldUseCache = "useCache" in args ? args.useCache : __privateGet(this, _useCache5);
          let data = shouldUseCache ? this.cache.getAll(args) : void 0;
          this._emitter.emit("notifications.list.pending", { args, data });
          if (!data) {
            const response = yield this._inboxService.fetchNotifications(__spreadValues({
              limit
            }, restOptions));
            data = {
              hasMore: response.hasMore,
              filter: response.filter,
              notifications: response.data.map((el) => new Notification(el, this._emitter, this._inboxService))
            };
            if (shouldUseCache) {
              this.cache.set(args, data);
              data = this.cache.getAll(args);
            }
          }
          this._emitter.emit("notifications.list.resolved", { args, data });
          return { data };
        } catch (error) {
          this._emitter.emit("notifications.list.resolved", { args, error });
          return { error: new NovuError("Failed to fetch notifications", error) };
        }
      }));
    });
  }
  count(args) {
    return __async(this, null, function* () {
      return this.callWithSession(() => __async(this, null, function* () {
        const filters = args && "filters" in args ? args.filters : [__spreadValues({}, args)];
        try {
          this._emitter.emit("notifications.count.pending", { args });
          const response = yield this._inboxService.count({
            filters
          });
          const data = args && "filters" in args ? { counts: response.data } : response.data[0];
          this._emitter.emit("notifications.count.resolved", {
            args,
            data
          });
          return { data };
        } catch (error) {
          this._emitter.emit("notifications.count.resolved", { args, error });
          return { error: new NovuError("Failed to count notifications", error) };
        }
      }));
    });
  }
  read(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return read({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unread(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unread({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  seen(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return seen({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  archive(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archive({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unarchive(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unarchive({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  delete(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return deleteNotification({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  snooze(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return snooze({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unsnooze(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unsnooze({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  completePrimary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return completeAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "primary" /* PRIMARY */
          });
        })
      );
    });
  }
  completeSecondary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return completeAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "secondary" /* SECONDARY */
          });
        })
      );
    });
  }
  revertPrimary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return revertAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "primary" /* PRIMARY */
          });
        })
      );
    });
  }
  revertSecondary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return revertAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "secondary" /* SECONDARY */
          });
        })
      );
    });
  }
  readAll() {
    return __async(this, arguments, function* ({
      tags,
      data
    } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return readAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags,
            data
          });
        })
      );
    });
  }
  seenAll() {
    return __async(this, arguments, function* (args = {}) {
      return this.callWithSession(() => __async(this, null, function* () {
        if ("notificationIds" in args) {
          return seenAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            notificationIds: args.notificationIds
          });
        } else {
          return seenAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags: "tags" in args ? args.tags : void 0,
            data: "data" in args ? args.data : void 0
          });
        }
      }));
    });
  }
  archiveAll() {
    return __async(this, arguments, function* ({
      tags,
      data
    } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archiveAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags,
            data
          });
        })
      );
    });
  }
  archiveAllRead() {
    return __async(this, arguments, function* ({ tags, data } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archiveAllRead({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags,
            data
          });
        })
      );
    });
  }
  deleteAll() {
    return __async(this, arguments, function* ({
      tags,
      data
    } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return deleteAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags,
            data
          });
        })
      );
    });
  }
  clearCache({ filter } = {}) {
    if (filter) {
      this.cache.clear(filter != null ? filter : {});
      return;
    }
    this.cache.clearAll();
  }
  triggerHelloWorldEvent() {
    return __async(this, null, function* () {
      return this._inboxService.triggerHelloWorldEvent();
    });
  }
};
_useCache5 = new WeakMap();

// src/preferences/schedule.ts
var _emitter5, _apiService, _cache6, _useCache6;
var Schedule = class {
  constructor(schedule, {
    emitterInstance,
    inboxServiceInstance,
    cache,
    useCache
  }) {
    __privateAdd(this, _emitter5);
    __privateAdd(this, _apiService);
    __privateAdd(this, _cache6);
    __privateAdd(this, _useCache6);
    __privateSet(this, _emitter5, emitterInstance);
    __privateSet(this, _apiService, inboxServiceInstance);
    __privateSet(this, _cache6, cache);
    __privateSet(this, _useCache6, useCache);
    this.isEnabled = schedule.isEnabled;
    this.weeklySchedule = schedule.weeklySchedule;
  }
  update(args) {
    return __async(this, null, function* () {
      var _a;
      const hasWeeklySchedule = !!args.weeklySchedule || !!this.weeklySchedule;
      return updateSchedule({
        emitter: __privateGet(this, _emitter5),
        apiService: __privateGet(this, _apiService),
        cache: __privateGet(this, _cache6),
        useCache: __privateGet(this, _useCache6),
        args: __spreadValues({
          isEnabled: (_a = args.isEnabled) != null ? _a : this.isEnabled
        }, hasWeeklySchedule && {
          weeklySchedule: __spreadValues(__spreadValues({}, this.weeklySchedule), args.weeklySchedule)
        })
      });
    });
  }
};
_emitter5 = new WeakMap();
_apiService = new WeakMap();
_cache6 = new WeakMap();
_useCache6 = new WeakMap();

// src/preferences/preference.ts
var _emitter6, _apiService2, _cache7, _scheduleCache, _useCache7;
var Preference = class {
  constructor(preference, {
    emitterInstance,
    inboxServiceInstance,
    cache,
    scheduleCache,
    useCache
  }) {
    __privateAdd(this, _emitter6);
    __privateAdd(this, _apiService2);
    __privateAdd(this, _cache7);
    __privateAdd(this, _scheduleCache);
    __privateAdd(this, _useCache7);
    __privateSet(this, _emitter6, emitterInstance);
    __privateSet(this, _apiService2, inboxServiceInstance);
    __privateSet(this, _cache7, cache);
    __privateSet(this, _scheduleCache, scheduleCache);
    __privateSet(this, _useCache7, useCache);
    this.level = preference.level;
    this.enabled = preference.enabled;
    this.channels = preference.channels;
    this.workflow = preference.workflow;
    this.schedule = new Schedule(
      __spreadValues({}, preference.schedule),
      { emitterInstance, inboxServiceInstance, cache: scheduleCache, useCache }
    );
  }
  update({
    channels,
    channelPreferences
  }) {
    var _a;
    return updatePreference({
      emitter: __privateGet(this, _emitter6),
      apiService: __privateGet(this, _apiService2),
      cache: __privateGet(this, _cache7),
      scheduleCache: __privateGet(this, _scheduleCache),
      useCache: __privateGet(this, _useCache7),
      args: {
        workflowId: (_a = this.workflow) == null ? void 0 : _a.id,
        channels: channels || channelPreferences,
        preference: this
      }
    });
  }
};
_emitter6 = new WeakMap();
_apiService2 = new WeakMap();
_cache7 = new WeakMap();
_scheduleCache = new WeakMap();
_useCache7 = new WeakMap();

// src/preferences/helpers.ts
var updatePreference = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args
}) {
  var _a;
  const { channels } = args;
  const workflowId = "workflowId" in args ? args.workflowId : (_a = args.preference.workflow) == null ? void 0 : _a.id;
  try {
    emitter.emit("preference.update.pending", {
      args,
      data: "preference" in args ? new Preference(
        __spreadProps(__spreadValues({}, args.preference), {
          channels: __spreadValues(__spreadValues({}, args.preference.channels), channels)
        }),
        {
          emitterInstance: emitter,
          inboxServiceInstance: apiService,
          cache,
          scheduleCache,
          useCache
        }
      ) : void 0
    });
    let response;
    if (workflowId) {
      response = yield apiService.updateWorkflowPreferences({ workflowId, channels });
    } else {
      optimisticUpdateWorkflowPreferences({ emitter, apiService, cache, scheduleCache, useCache, args });
      response = yield apiService.updateGlobalPreferences(channels);
    }
    const preference = new Preference(response, {
      emitterInstance: emitter,
      inboxServiceInstance: apiService,
      cache,
      scheduleCache,
      useCache
    });
    emitter.emit("preference.update.resolved", { args, data: preference });
    return { data: preference };
  } catch (error) {
    emitter.emit("preference.update.resolved", { args, error });
    return { error: new NovuError("Failed to update preference", error) };
  }
});
var bulkUpdatePreference = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args
}) {
  const globalPreference = args.find((arg) => "preference" in arg && arg.preference.level === "global" /* GLOBAL */);
  if (globalPreference) {
    return { error: new NovuError("Global preference is not supported in bulk update", "") };
  }
  try {
    const optimisticallyUpdatedPreferences = args.map(
      (arg) => "preference" in arg ? new Preference(
        __spreadProps(__spreadValues({}, arg.preference), {
          channels: __spreadValues(__spreadValues({}, arg.preference.channels), arg.channels)
        }),
        {
          emitterInstance: emitter,
          inboxServiceInstance: apiService,
          cache,
          scheduleCache,
          useCache
        }
      ) : void 0
    ).filter((el) => el !== void 0);
    emitter.emit("preferences.bulk_update.pending", {
      args,
      data: optimisticallyUpdatedPreferences
    });
    const preferencesToUpdate = args.map((arg) => {
      var _a, _b, _c, _d;
      return __spreadValues({
        workflowId: "workflowId" in arg ? arg.workflowId : (_d = (_c = (_a = arg.preference.workflow) == null ? void 0 : _a.id) != null ? _c : (_b = arg.preference.workflow) == null ? void 0 : _b.identifier) != null ? _d : ""
      }, arg.channels);
    });
    const response = yield apiService.bulkUpdatePreferences(preferencesToUpdate);
    const preferences = response.map(
      (el) => new Preference(el, {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        scheduleCache,
        useCache
      })
    );
    emitter.emit("preferences.bulk_update.resolved", { args, data: preferences });
    return { data: preferences };
  } catch (error) {
    emitter.emit("preferences.bulk_update.resolved", { args, error });
    return { error: new NovuError("Failed to bulk update preferences", error) };
  }
});
var optimisticUpdateWorkflowPreferences = ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args
}) => {
  const allPreferences = useCache ? cache == null ? void 0 : cache.getAll({}) : void 0;
  allPreferences == null ? void 0 : allPreferences.forEach((el) => {
    var _a, _b;
    if (el.level === "template" /* TEMPLATE */) {
      const mergedPreference = __spreadProps(__spreadValues({}, el), {
        channels: Object.entries(el.channels).reduce((acc, [key, value]) => {
          var _a2;
          const channelType = key;
          acc[channelType] = (_a2 = args.channels[channelType]) != null ? _a2 : value;
          return acc;
        }, {})
      });
      const updatedPreference = "preference" in args ? new Preference(mergedPreference, {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        scheduleCache,
        useCache
      }) : void 0;
      if (updatedPreference) {
        emitter.emit("preference.update.pending", {
          args: {
            workflowId: (_b = (_a = el.workflow) == null ? void 0 : _a.id) != null ? _b : "",
            channels: updatedPreference.channels
          },
          data: updatedPreference
        });
      }
    }
  });
};
var updateSchedule = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache,
  useCache,
  args
}) {
  var _a, _b;
  try {
    const { isEnabled, weeklySchedule } = args;
    const optimisticallyUpdatedSchedule = new Schedule(
      {
        isEnabled,
        weeklySchedule
      },
      {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        useCache
      }
    );
    emitter.emit("preference.schedule.update.pending", { args, data: optimisticallyUpdatedSchedule });
    const response = yield apiService.updateGlobalPreferences({
      schedule: {
        isEnabled,
        weeklySchedule
      }
    });
    const updatedSchedule = new Schedule(
      {
        isEnabled: (_a = response.schedule) == null ? void 0 : _a.isEnabled,
        weeklySchedule: (_b = response.schedule) == null ? void 0 : _b.weeklySchedule
      },
      {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        useCache
      }
    );
    emitter.emit("preference.schedule.update.resolved", {
      args,
      data: updatedSchedule
    });
    return { data: updatedSchedule };
  } catch (error) {
    emitter.emit("preference.schedule.update.resolved", { args, error });
    return { error: new NovuError("Failed to update preference", error) };
  }
});

// src/preferences/preference-schedule.ts
var _useCache8;
var PreferenceSchedule = class extends BaseModule {
  constructor({
    cache,
    useCache,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache8);
    this.cache = cache;
    __privateSet(this, _useCache8, useCache);
  }
  get() {
    return __async(this, null, function* () {
      return this.callWithSession(() => __async(this, null, function* () {
        var _a, _b;
        try {
          let data = __privateGet(this, _useCache8) ? this.cache.getAll() : void 0;
          this._emitter.emit("preference.schedule.get.pending", { args: void 0, data });
          if (!data) {
            const globalPreference = yield this._inboxService.fetchGlobalPreferences();
            data = new Schedule(
              {
                isEnabled: (_a = globalPreference == null ? void 0 : globalPreference.schedule) == null ? void 0 : _a.isEnabled,
                weeklySchedule: (_b = globalPreference == null ? void 0 : globalPreference.schedule) == null ? void 0 : _b.weeklySchedule
              },
              {
                emitterInstance: this._emitter,
                inboxServiceInstance: this._inboxService,
                cache: this.cache,
                useCache: __privateGet(this, _useCache8)
              }
            );
            if (__privateGet(this, _useCache8)) {
              this.cache.set(data);
              data = this.cache.getAll();
            }
          }
          this._emitter.emit("preference.schedule.get.resolved", {
            args: void 0,
            data
          });
          return { data };
        } catch (error) {
          this._emitter.emit("preference.schedule.get.resolved", { args: void 0, error });
          throw error;
        }
      }));
    });
  }
  update(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => updateSchedule({
          emitter: this._emitter,
          apiService: this._inboxService,
          cache: this.cache,
          useCache: __privateGet(this, _useCache8),
          args
        })
      );
    });
  }
};
_useCache8 = new WeakMap();

// src/cache/preferences-cache.ts
var updateEvents2 = [
  "preference.update.pending",
  "preference.update.resolved",
  "preferences.bulk_update.pending",
  "preferences.bulk_update.resolved"
];
var scheduleUpdateEvents = [
  "preference.schedule.update.pending",
  "preference.schedule.update.resolved"
];
var excludeEmpty2 = ({ tags, severity }) => Object.entries({ tags, severity }).reduce((acc, [key, value]) => {
  if (value === null || value === void 0 || Array.isArray(value) && value.length === 0) {
    return acc;
  }
  acc[key] = value;
  return acc;
}, {});
var getCacheKey2 = ({ tags, severity }) => {
  return JSON.stringify(excludeEmpty2({ tags, severity }));
};
var _emitter7, _cache8;
var PreferencesCache = class {
  constructor({ emitterInstance }) {
    __privateAdd(this, _emitter7);
    __privateAdd(this, _cache8);
    this.updatePreference = (key, data) => {
      const preferences = __privateGet(this, _cache8).get(key);
      if (!preferences) {
        return false;
      }
      const index = preferences.findIndex(
        (el) => {
          var _a, _b;
          return ((_a = el.workflow) == null ? void 0 : _a.id) === ((_b = data.workflow) == null ? void 0 : _b.id) || el.level === data.level && data.level === "global" /* GLOBAL */;
        }
      );
      if (index === -1) {
        return false;
      }
      const updatedPreferences = [...preferences];
      updatedPreferences[index] = data;
      __privateGet(this, _cache8).set(key, updatedPreferences);
      return true;
    };
    this.updatePreferenceSchedule = (key, data) => {
      const preferences = __privateGet(this, _cache8).get(key);
      if (!preferences) {
        return false;
      }
      const index = preferences.findIndex((el) => el.level === "global" /* GLOBAL */);
      if (index === -1) {
        return false;
      }
      const updatedPreferences = [...preferences];
      updatedPreferences[index].schedule = data;
      __privateGet(this, _cache8).set(key, updatedPreferences);
      return true;
    };
    this.handleScheduleEvent = ({ data }) => {
      var _a;
      if (!data) {
        return;
      }
      const cacheKeys = __privateGet(this, _cache8).keys();
      const uniqueFilterKeys = /* @__PURE__ */ new Set();
      for (const key of cacheKeys) {
        const hasUpdatedPreference = this.updatePreferenceSchedule(key, data);
        const updatedPreference = __privateGet(this, _cache8).get(key);
        if (!hasUpdatedPreference || !updatedPreference) {
          continue;
        }
        uniqueFilterKeys.add(key);
      }
      for (const key of uniqueFilterKeys) {
        __privateGet(this, _emitter7).emit("preferences.list.updated", {
          data: (_a = __privateGet(this, _cache8).get(key)) != null ? _a : []
        });
      }
    };
    this.handlePreferenceEvent = ({ data }) => {
      if (!data) {
        return;
      }
      const preferences = Array.isArray(data) ? data : [data];
      const uniqueFilterKeys = /* @__PURE__ */ new Set();
      __privateGet(this, _cache8).keys().forEach((key) => {
        preferences.forEach((preference) => {
          const hasUpdatedPreference = this.updatePreference(key, preference);
          const updatedPreference = __privateGet(this, _cache8).get(key);
          if (!hasUpdatedPreference || !updatedPreference) {
            return;
          }
          uniqueFilterKeys.add(key);
        });
      });
      uniqueFilterKeys.forEach((key) => {
        var _a;
        __privateGet(this, _emitter7).emit("preferences.list.updated", {
          data: (_a = __privateGet(this, _cache8).get(key)) != null ? _a : []
        });
      });
    };
    __privateSet(this, _emitter7, emitterInstance);
    for (const event of updateEvents2) {
      __privateGet(this, _emitter7).on(event, this.handlePreferenceEvent);
    }
    for (const event of scheduleUpdateEvents) {
      __privateGet(this, _emitter7).on(event, this.handleScheduleEvent);
    }
    __privateSet(this, _cache8, new InMemoryCache());
  }
  has(args) {
    return __privateGet(this, _cache8).get(getCacheKey2(args)) !== void 0;
  }
  set(args, data) {
    __privateGet(this, _cache8).set(getCacheKey2(args), data);
  }
  getAll(args) {
    if (this.has(args)) {
      return __privateGet(this, _cache8).get(getCacheKey2(args));
    }
  }
  clearAll() {
    __privateGet(this, _cache8).clear();
  }
};
_emitter7 = new WeakMap();
_cache8 = new WeakMap();

// src/cache/schedule-cache.ts
var updateEvents3 = [
  "preference.schedule.update.pending",
  "preference.schedule.update.resolved"
];
var getCacheKey3 = () => {
  return "schedule";
};
var _emitter8, _cache9;
var ScheduleCache = class {
  constructor({ emitterInstance }) {
    __privateAdd(this, _emitter8);
    __privateAdd(this, _cache9);
    this.updateScheduleInCache = (key, data) => {
      const schedule = __privateGet(this, _cache9).get(key);
      if (!schedule) {
        return false;
      }
      __privateGet(this, _cache9).set(key, data);
      return true;
    };
    this.handleScheduleEvent = ({ data }) => {
      if (!data) {
        return;
      }
      const uniqueFilterKeys = /* @__PURE__ */ new Set();
      const keys = __privateGet(this, _cache9).keys();
      for (const key of keys) {
        const hasUpdatedSchedule = this.updateScheduleInCache(key, data);
        const updatedSchedule = __privateGet(this, _cache9).get(key);
        if (!hasUpdatedSchedule || !updatedSchedule) {
          continue;
        }
        uniqueFilterKeys.add(key);
      }
      for (const key of uniqueFilterKeys) {
        __privateGet(this, _emitter8).emit("preference.schedule.get.updated", {
          data: __privateGet(this, _cache9).get(key)
        });
      }
    };
    __privateSet(this, _emitter8, emitterInstance);
    for (const event of updateEvents3) {
      __privateGet(this, _emitter8).on(event, this.handleScheduleEvent);
    }
    __privateSet(this, _cache9, new InMemoryCache());
  }
  has() {
    return __privateGet(this, _cache9).get(getCacheKey3()) !== void 0;
  }
  set(data) {
    __privateGet(this, _cache9).set(getCacheKey3(), data);
  }
  getAll() {
    if (this.has()) {
      return __privateGet(this, _cache9).get(getCacheKey3());
    }
  }
  clearAll() {
    __privateGet(this, _cache9).clear();
  }
};
_emitter8 = new WeakMap();
_cache9 = new WeakMap();

// src/preferences/preferences.ts
var _useCache9;
var Preferences = class extends BaseModule {
  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache9);
    this.cache = new PreferencesCache({
      emitterInstance: this._emitter
    });
    this.scheduleCache = new ScheduleCache({
      emitterInstance: this._emitter
    });
    __privateSet(this, _useCache9, useCache);
    this.schedule = new PreferenceSchedule({
      cache: this.scheduleCache,
      useCache,
      inboxServiceInstance,
      eventEmitterInstance
    });
  }
  list() {
    return __async(this, arguments, function* (args = {}) {
      return this.callWithSession(() => __async(this, null, function* () {
        var _a;
        try {
          let data = __privateGet(this, _useCache9) ? this.cache.getAll(args) : void 0;
          this._emitter.emit("preferences.list.pending", { args, data });
          if (!data) {
            const response = yield this._inboxService.fetchPreferences({
              tags: args.tags,
              severity: args.severity,
              criticality: (_a = args.criticality) != null ? _a : "nonCritical" /* NON_CRITICAL */
            });
            data = response.map(
              (el) => new Preference(el, {
                emitterInstance: this._emitter,
                inboxServiceInstance: this._inboxService,
                cache: this.cache,
                scheduleCache: this.scheduleCache,
                useCache: __privateGet(this, _useCache9)
              })
            );
            if (__privateGet(this, _useCache9)) {
              this.cache.set(args, data);
              data = this.cache.getAll(args);
            }
          }
          this._emitter.emit("preferences.list.resolved", { args, data });
          return { data };
        } catch (error) {
          this._emitter.emit("preferences.list.resolved", { args, error });
          throw error;
        }
      }));
    });
  }
  update(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => updatePreference({
          emitter: this._emitter,
          apiService: this._inboxService,
          cache: this.cache,
          scheduleCache: this.scheduleCache,
          useCache: __privateGet(this, _useCache9),
          args
        })
      );
    });
  }
  bulkUpdate(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => bulkUpdatePreference({
          emitter: this._emitter,
          apiService: this._inboxService,
          cache: this.cache,
          scheduleCache: this.scheduleCache,
          useCache: __privateGet(this, _useCache9),
          args
        })
      );
    });
  }
};
_useCache9 = new WeakMap();

// src/utils/is-browser.ts
function isBrowser() {
  return typeof window !== "undefined";
}

// src/session/session.ts
var _emitter9, _inboxService5, _options;
var Session = class {
  constructor(options, inboxServiceInstance, eventEmitterInstance) {
    __privateAdd(this, _emitter9);
    __privateAdd(this, _inboxService5);
    __privateAdd(this, _options);
    __privateSet(this, _emitter9, eventEmitterInstance);
    __privateSet(this, _inboxService5, inboxServiceInstance);
    __privateSet(this, _options, options);
  }
  get applicationIdentifier() {
    return __privateGet(this, _options).applicationIdentifier;
  }
  get subscriberId() {
    var _a;
    return (_a = __privateGet(this, _options).subscriber) == null ? void 0 : _a.subscriberId;
  }
  get context() {
    return __privateGet(this, _options).context;
  }
  get subscriberHash() {
    return __privateGet(this, _options).subscriberHash;
  }
  get contextHash() {
    return __privateGet(this, _options).contextHash;
  }
  get subscriber() {
    return __privateGet(this, _options).subscriber;
  }
  handleApplicationIdentifier(method, identifier) {
    if (typeof window === "undefined" || !window.localStorage) {
      return null;
    }
    const key = "novu_keyless_application_identifier";
    switch (method) {
      case "get": {
        return window.localStorage.getItem(key);
      }
      case "store": {
        if (identifier) {
          window.localStorage.setItem(key, identifier);
        }
        return null;
      }
      case "delete": {
        window.localStorage.removeItem(key);
        return null;
      }
      default:
        return null;
    }
  }
  initialize(options) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f;
      const subscriberUnchanged = ((_a = __privateGet(this, _options).subscriber) == null ? void 0 : _a.subscriberId) === ((_b = options == null ? void 0 : options.subscriber) == null ? void 0 : _b.subscriberId);
      const contextUnchanged = JSON.stringify(__privateGet(this, _options).context) === JSON.stringify(options == null ? void 0 : options.context);
      if (subscriberUnchanged && contextUnchanged) {
        return;
      }
      try {
        if (options) {
          __privateSet(this, _options, options);
        }
        const { subscriber, subscriberHash, contextHash, applicationIdentifier, defaultSchedule, context } = __privateGet(this, _options);
        let currentTimezone;
        if (isBrowser()) {
          currentTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        let finalApplicationIdentifier = applicationIdentifier;
        if (!finalApplicationIdentifier) {
          const storedAppId = this.handleApplicationIdentifier("get");
          if (storedAppId) {
            finalApplicationIdentifier = storedAppId;
          }
        } else {
          this.handleApplicationIdentifier("delete");
        }
        __privateGet(this, _emitter9).emit("session.initialize.pending", { args: __privateGet(this, _options) });
        const response = yield __privateGet(this, _inboxService5).initializeSession({
          applicationIdentifier: finalApplicationIdentifier,
          subscriberHash,
          contextHash,
          subscriber: __spreadProps(__spreadValues({}, subscriber), {
            subscriberId: (_c = subscriber == null ? void 0 : subscriber.subscriberId) != null ? _c : "",
            timezone: (_d = subscriber == null ? void 0 : subscriber.timezone) != null ? _d : currentTimezone
          }),
          defaultSchedule,
          context
        });
        if ((_e = response == null ? void 0 : response.applicationIdentifier) == null ? void 0 : _e.startsWith("pk_keyless_")) {
          this.handleApplicationIdentifier("store", response.applicationIdentifier);
        }
        if (!((_f = response == null ? void 0 : response.applicationIdentifier) == null ? void 0 : _f.startsWith("pk_keyless_"))) {
          this.handleApplicationIdentifier("delete");
        }
        __privateGet(this, _emitter9).emit("session.initialize.resolved", { args: __privateGet(this, _options), data: response });
      } catch (error) {
        __privateGet(this, _emitter9).emit("session.initialize.resolved", { args: __privateGet(this, _options), error });
      }
    });
  }
};
_emitter9 = new WeakMap();
_inboxService5 = new WeakMap();
_options = new WeakMap();
var PRODUCTION_SOCKET_URL = "wss://socket.novu.co";
var NOTIFICATION_RECEIVED = "notifications.notification_received";
var UNSEEN_COUNT_CHANGED = "notifications.unseen_count_changed";
var UNREAD_COUNT_CHANGED = "notifications.unread_count_changed";
var mapToNotification = ({
  _id,
  transactionId,
  content,
  read: read2,
  seen: seen2,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  firstSeenDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  data,
  workflow,
  severity
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const to = {
    id: subscriber == null ? void 0 : subscriber._id,
    subscriberId: subscriber == null ? void 0 : subscriber.subscriberId,
    firstName: subscriber == null ? void 0 : subscriber.firstName,
    lastName: subscriber == null ? void 0 : subscriber.lastName,
    avatar: subscriber == null ? void 0 : subscriber.avatar,
    locale: subscriber == null ? void 0 : subscriber.locale,
    data: subscriber == null ? void 0 : subscriber.data,
    timezone: subscriber == null ? void 0 : subscriber.timezone,
    email: subscriber == null ? void 0 : subscriber.email,
    phone: subscriber == null ? void 0 : subscriber.phone
  };
  const primaryCta = (_b = (_a = cta.action) == null ? void 0 : _a.buttons) == null ? void 0 : _b.find((button) => button.type === "primary" /* PRIMARY */);
  const secondaryCta = (_d = (_c = cta.action) == null ? void 0 : _c.buttons) == null ? void 0 : _d.find((button) => button.type === "secondary" /* SECONDARY */);
  const actionType = (_f = (_e = cta.action) == null ? void 0 : _e.result) == null ? void 0 : _f.type;
  const actionStatus = (_g = cta.action) == null ? void 0 : _g.status;
  return __spreadProps(__spreadValues(__spreadValues({
    id: _id,
    transactionId,
    subject,
    body: content,
    to,
    isRead: read2,
    isSeen: seen2,
    isArchived: archived,
    isSnoozed: !!snoozedUntil
  }, deliveredAt && {
    deliveredAt
  }), snoozedUntil && {
    snoozedUntil
  }), {
    createdAt,
    readAt: lastReadDate,
    firstSeenAt: firstSeenDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === "primary" /* PRIMARY */ && actionStatus === "done" /* DONE */,
      redirect: primaryCta.url ? {
        target: primaryCta.target,
        url: primaryCta.url
      } : void 0
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === "secondary" /* SECONDARY */ && actionStatus === "done" /* DONE */,
      redirect: secondaryCta.url ? {
        target: secondaryCta.target,
        url: secondaryCta.url
      } : void 0
    },
    channelType: channel,
    tags,
    redirect: ((_h = cta.data) == null ? void 0 : _h.url) ? {
      url: cta.data.url,
      target: cta.data.target
    } : void 0,
    data,
    workflow,
    severity
  });
};
var _token, _emitter10, _partySocket, _socketUrl, _notificationReceived, _unseenCountChanged, _unreadCountChanged, _handleMessage, _PartySocketClient_instances, initializeSocket_fn, handleConnectSocket_fn, handleDisconnectSocket_fn;
var PartySocketClient = class extends BaseModule {
  constructor({
    socketUrl,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _PartySocketClient_instances);
    __privateAdd(this, _token);
    __privateAdd(this, _emitter10);
    __privateAdd(this, _partySocket);
    __privateAdd(this, _socketUrl);
    __privateAdd(this, _notificationReceived, (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.event === "notification_received" /* RECEIVED */) {
          __privateGet(this, _emitter10).emit(NOTIFICATION_RECEIVED, {
            result: new Notification(mapToNotification(data.data.message), __privateGet(this, _emitter10), this._inboxService)
          });
        }
      } catch (error) {
        console.log("error", error);
      }
    });
    __privateAdd(this, _unseenCountChanged, (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.event === "unseen_count_changed" /* UNSEEN */) {
          __privateGet(this, _emitter10).emit(UNSEEN_COUNT_CHANGED, {
            result: data.data.unseenCount
          });
        }
      } catch (error) {
      }
    });
    __privateAdd(this, _unreadCountChanged, (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.event === "unread_count_changed" /* UNREAD */) {
          __privateGet(this, _emitter10).emit(UNREAD_COUNT_CHANGED, {
            result: data.data.counts
          });
        }
      } catch (error) {
      }
    });
    __privateAdd(this, _handleMessage, (event) => {
      try {
        const data = JSON.parse(event.data);
        switch (data.event) {
          case "notification_received" /* RECEIVED */:
            __privateGet(this, _notificationReceived).call(this, event);
            break;
          case "unseen_count_changed" /* UNSEEN */:
            __privateGet(this, _unseenCountChanged).call(this, event);
            break;
          case "unread_count_changed" /* UNREAD */:
            __privateGet(this, _unreadCountChanged).call(this, event);
            break;
          default:
        }
      } catch (error) {
      }
    });
    __privateSet(this, _emitter10, eventEmitterInstance);
    __privateSet(this, _socketUrl, socketUrl != null ? socketUrl : PRODUCTION_SOCKET_URL);
  }
  onSessionSuccess({ token }) {
    __privateSet(this, _token, token);
  }
  isSocketEvent(eventName) {
    return eventName === NOTIFICATION_RECEIVED || eventName === UNSEEN_COUNT_CHANGED || eventName === UNREAD_COUNT_CHANGED;
  }
  connect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _token)) {
        return __privateMethod(this, _PartySocketClient_instances, handleConnectSocket_fn).call(this);
      }
      return this.callWithSession(__privateMethod(this, _PartySocketClient_instances, handleConnectSocket_fn).bind(this));
    });
  }
  disconnect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _partySocket)) {
        return __privateMethod(this, _PartySocketClient_instances, handleDisconnectSocket_fn).call(this);
      }
      return this.callWithSession(__privateMethod(this, _PartySocketClient_instances, handleDisconnectSocket_fn).bind(this));
    });
  }
};
_token = new WeakMap();
_emitter10 = new WeakMap();
_partySocket = new WeakMap();
_socketUrl = new WeakMap();
_notificationReceived = new WeakMap();
_unseenCountChanged = new WeakMap();
_unreadCountChanged = new WeakMap();
_handleMessage = new WeakMap();
_PartySocketClient_instances = new WeakSet();
initializeSocket_fn = function() {
  return __async(this, null, function* () {
    if (__privateGet(this, _partySocket)) {
      return;
    }
    const args = { socketUrl: __privateGet(this, _socketUrl) };
    __privateGet(this, _emitter10).emit("socket.connect.pending", { args });
    const url = new URL(__privateGet(this, _socketUrl));
    url.searchParams.set("token", __privateGet(this, _token));
    __privateSet(this, _partySocket, new WebSocket(url.toString()));
    __privateGet(this, _partySocket).addEventListener("open", () => {
      __privateGet(this, _emitter10).emit("socket.connect.resolved", { args });
    });
    __privateGet(this, _partySocket).addEventListener("error", (error) => {
      __privateGet(this, _emitter10).emit("socket.connect.resolved", { args, error });
    });
    __privateGet(this, _partySocket).addEventListener("message", __privateGet(this, _handleMessage));
  });
};
handleConnectSocket_fn = function() {
  return __async(this, null, function* () {
    try {
      yield __privateMethod(this, _PartySocketClient_instances, initializeSocket_fn).call(this);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to initialize the PartySocket", error) };
    }
  });
};
handleDisconnectSocket_fn = function() {
  return __async(this, null, function* () {
    var _a;
    try {
      (_a = __privateGet(this, _partySocket)) == null ? void 0 : _a.close();
      __privateSet(this, _partySocket, void 0);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to disconnect from the PartySocket", error) };
    }
  });
};
var PRODUCTION_SOCKET_URL2 = "https://ws.novu.co";
var NOTIFICATION_RECEIVED2 = "notifications.notification_received";
var UNSEEN_COUNT_CHANGED2 = "notifications.unseen_count_changed";
var UNREAD_COUNT_CHANGED2 = "notifications.unread_count_changed";
var mapToNotification2 = ({
  _id,
  transactionId,
  content,
  read: read2,
  seen: seen2,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  firstSeenDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  data,
  workflow,
  severity
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const to = {
    id: subscriber == null ? void 0 : subscriber._id,
    subscriberId: subscriber == null ? void 0 : subscriber.subscriberId,
    firstName: subscriber == null ? void 0 : subscriber.firstName,
    lastName: subscriber == null ? void 0 : subscriber.lastName,
    avatar: subscriber == null ? void 0 : subscriber.avatar,
    locale: subscriber == null ? void 0 : subscriber.locale,
    data: subscriber == null ? void 0 : subscriber.data,
    timezone: subscriber == null ? void 0 : subscriber.timezone,
    email: subscriber == null ? void 0 : subscriber.email,
    phone: subscriber == null ? void 0 : subscriber.phone
  };
  const primaryCta = (_b = (_a = cta.action) == null ? void 0 : _a.buttons) == null ? void 0 : _b.find((button) => button.type === "primary" /* PRIMARY */);
  const secondaryCta = (_d = (_c = cta.action) == null ? void 0 : _c.buttons) == null ? void 0 : _d.find((button) => button.type === "secondary" /* SECONDARY */);
  const actionType = (_f = (_e = cta.action) == null ? void 0 : _e.result) == null ? void 0 : _f.type;
  const actionStatus = (_g = cta.action) == null ? void 0 : _g.status;
  return __spreadProps(__spreadValues(__spreadValues({
    id: _id,
    transactionId,
    subject,
    body: content,
    to,
    isRead: read2,
    isSeen: seen2,
    isArchived: archived,
    isSnoozed: !!snoozedUntil
  }, deliveredAt && {
    deliveredAt
  }), snoozedUntil && {
    snoozedUntil
  }), {
    createdAt,
    readAt: lastReadDate,
    firstSeenAt: firstSeenDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === "primary" /* PRIMARY */ && actionStatus === "done" /* DONE */,
      redirect: primaryCta.url ? {
        target: primaryCta.target,
        url: primaryCta.url
      } : void 0
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === "secondary" /* SECONDARY */ && actionStatus === "done" /* DONE */,
      redirect: secondaryCta.url ? {
        target: secondaryCta.target,
        url: secondaryCta.url
      } : void 0
    },
    channelType: channel,
    tags,
    redirect: ((_h = cta.data) == null ? void 0 : _h.url) ? {
      url: cta.data.url,
      target: cta.data.target
    } : void 0,
    data,
    workflow,
    severity
  });
};
var _token2, _emitter11, _socketIo, _socketUrl2, _notificationReceived2, _unseenCountChanged2, _unreadCountChanged2, _Socket_instances, initializeSocket_fn2, handleConnectSocket_fn2, handleDisconnectSocket_fn2;
var Socket = class extends BaseModule {
  constructor({
    socketUrl,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _Socket_instances);
    __privateAdd(this, _token2);
    __privateAdd(this, _emitter11);
    __privateAdd(this, _socketIo);
    __privateAdd(this, _socketUrl2);
    __privateAdd(this, _notificationReceived2, ({ message }) => {
      __privateGet(this, _emitter11).emit(NOTIFICATION_RECEIVED2, {
        result: new Notification(mapToNotification2(message), __privateGet(this, _emitter11), this._inboxService)
      });
    });
    __privateAdd(this, _unseenCountChanged2, ({ unseenCount }) => {
      __privateGet(this, _emitter11).emit(UNSEEN_COUNT_CHANGED2, {
        result: unseenCount
      });
    });
    __privateAdd(this, _unreadCountChanged2, ({ counts }) => {
      __privateGet(this, _emitter11).emit(UNREAD_COUNT_CHANGED2, {
        result: counts
      });
    });
    __privateSet(this, _emitter11, eventEmitterInstance);
    __privateSet(this, _socketUrl2, socketUrl != null ? socketUrl : PRODUCTION_SOCKET_URL2);
  }
  onSessionSuccess({ token }) {
    __privateSet(this, _token2, token);
  }
  isSocketEvent(eventName) {
    return eventName === NOTIFICATION_RECEIVED2 || eventName === UNSEEN_COUNT_CHANGED2 || eventName === UNREAD_COUNT_CHANGED2;
  }
  connect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _token2)) {
        return __privateMethod(this, _Socket_instances, handleConnectSocket_fn2).call(this);
      }
      return this.callWithSession(__privateMethod(this, _Socket_instances, handleConnectSocket_fn2).bind(this));
    });
  }
  disconnect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _socketIo)) {
        return __privateMethod(this, _Socket_instances, handleDisconnectSocket_fn2).call(this);
      }
      return this.callWithSession(__privateMethod(this, _Socket_instances, handleDisconnectSocket_fn2).bind(this));
    });
  }
};
_token2 = new WeakMap();
_emitter11 = new WeakMap();
_socketIo = new WeakMap();
_socketUrl2 = new WeakMap();
_notificationReceived2 = new WeakMap();
_unseenCountChanged2 = new WeakMap();
_unreadCountChanged2 = new WeakMap();
_Socket_instances = new WeakSet();
initializeSocket_fn2 = function() {
  return __async(this, null, function* () {
    var _a, _b, _c;
    if (__privateGet(this, _socketIo)) {
      return;
    }
    const args = { socketUrl: __privateGet(this, _socketUrl2) };
    __privateGet(this, _emitter11).emit("socket.connect.pending", { args });
    __privateSet(this, _socketIo, io(__privateGet(this, _socketUrl2), {
      reconnectionDelayMax: 1e4,
      transports: ["websocket"],
      query: {
        token: `${__privateGet(this, _token2)}`
      }
    }));
    __privateGet(this, _socketIo).on("connect", () => {
      __privateGet(this, _emitter11).emit("socket.connect.resolved", { args });
    });
    __privateGet(this, _socketIo).on("connect_error", (error) => {
      __privateGet(this, _emitter11).emit("socket.connect.resolved", { args, error });
    });
    (_a = __privateGet(this, _socketIo)) == null ? void 0 : _a.on("notification_received" /* RECEIVED */, __privateGet(this, _notificationReceived2));
    (_b = __privateGet(this, _socketIo)) == null ? void 0 : _b.on("unseen_count_changed" /* UNSEEN */, __privateGet(this, _unseenCountChanged2));
    (_c = __privateGet(this, _socketIo)) == null ? void 0 : _c.on("unread_count_changed" /* UNREAD */, __privateGet(this, _unreadCountChanged2));
  });
};
handleConnectSocket_fn2 = function() {
  return __async(this, null, function* () {
    try {
      yield __privateMethod(this, _Socket_instances, initializeSocket_fn2).call(this);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to initialize the socket", error) };
    }
  });
};
handleDisconnectSocket_fn2 = function() {
  return __async(this, null, function* () {
    var _a;
    try {
      (_a = __privateGet(this, _socketIo)) == null ? void 0 : _a.disconnect();
      __privateSet(this, _socketIo, void 0);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to disconnect from the socket", error) };
    }
  });
};

// src/ws/socket-factory.ts
var PARTY_SOCKET_URLS = [
  "wss://eu.socket.novu.co",
  PRODUCTION_SOCKET_URL,
  "wss://socket.novu-staging.co",
  "wss://socket-worker-local.cli-shortener.workers.dev"
];
var URL_TRANSFORMATIONS = {
  "https://eu.ws.novu.co": "wss://eu.socket.novu.co",
  "https://ws.novu.co": PRODUCTION_SOCKET_URL,
  "https://dev.ws.novu.co": "wss://socket.novu-staging.co"
};
function transformSocketUrl(socketUrl) {
  if (!socketUrl) return PRODUCTION_SOCKET_URL;
  return URL_TRANSFORMATIONS[socketUrl] || socketUrl;
}
function shouldUsePartySocket(socketUrl) {
  return !socketUrl || PARTY_SOCKET_URLS.includes(socketUrl);
}
function createSocket({
  socketUrl,
  inboxServiceInstance,
  eventEmitterInstance
}) {
  const transformedSocketUrl = transformSocketUrl(socketUrl);
  const socketType = shouldUsePartySocket(transformedSocketUrl) ? "partysocket" /* PARTY_SOCKET */ : "socket.io" /* SOCKET_IO */;
  switch (socketType) {
    case "partysocket" /* PARTY_SOCKET */:
      return new PartySocketClient({
        socketUrl: transformedSocketUrl,
        inboxServiceInstance,
        eventEmitterInstance
      });
    case "socket.io" /* SOCKET_IO */:
    default:
      return new Socket({
        socketUrl: transformedSocketUrl,
        inboxServiceInstance,
        eventEmitterInstance
      });
  }
}

// src/novu.ts
var _emitter12, _session, _inboxService6, _options2;
var Novu = class {
  constructor(options) {
    __privateAdd(this, _emitter12);
    __privateAdd(this, _session);
    __privateAdd(this, _inboxService6);
    __privateAdd(this, _options2);
    var _a, _b, _c;
    __privateSet(this, _options2, options);
    __privateSet(this, _inboxService6, new InboxService({
      apiUrl: options.apiUrl || options.backendUrl,
      userAgent: options.__userAgent
    }));
    __privateSet(this, _emitter12, new NovuEventEmitter());
    const subscriber = buildSubscriber({ subscriberId: options.subscriberId, subscriber: options.subscriber });
    const contextKey = buildContextKey(options.context);
    __privateSet(this, _session, new Session(
      {
        applicationIdentifier: options.applicationIdentifier || "",
        subscriberHash: options.subscriberHash,
        subscriber,
        defaultSchedule: options.defaultSchedule,
        context: options.context,
        contextHash: options.contextHash
      },
      __privateGet(this, _inboxService6),
      __privateGet(this, _emitter12)
    ));
    __privateGet(this, _session).initialize();
    this.notifications = new Notifications({
      useCache: (_a = options.useCache) != null ? _a : true,
      inboxServiceInstance: __privateGet(this, _inboxService6),
      eventEmitterInstance: __privateGet(this, _emitter12)
    });
    this.preferences = new Preferences({
      useCache: (_b = options.useCache) != null ? _b : true,
      inboxServiceInstance: __privateGet(this, _inboxService6),
      eventEmitterInstance: __privateGet(this, _emitter12)
    });
    this.subscriptions = new Subscriptions({
      subscriber,
      contextKey,
      useCache: (_c = options.useCache) != null ? _c : true,
      inboxServiceInstance: __privateGet(this, _inboxService6),
      eventEmitterInstance: __privateGet(this, _emitter12)
    });
    this.socket = createSocket({
      socketUrl: options.socketUrl,
      eventEmitterInstance: __privateGet(this, _emitter12),
      inboxServiceInstance: __privateGet(this, _inboxService6)
    });
    this.on = (eventName, listener) => {
      if (this.socket.isSocketEvent(eventName)) {
        this.socket.connect();
      }
      const cleanup = __privateGet(this, _emitter12).on(eventName, listener);
      return () => {
        cleanup();
      };
    };
    this.off = (eventName, listener) => {
      __privateGet(this, _emitter12).off(eventName, listener);
    };
  }
  get applicationIdentifier() {
    return __privateGet(this, _session).applicationIdentifier;
  }
  get subscriberId() {
    return __privateGet(this, _session).subscriberId;
  }
  get context() {
    return __privateGet(this, _session).context;
  }
  get options() {
    return __privateGet(this, _options2);
  }
  get contextKey() {
    return buildContextKey(__privateGet(this, _session).context);
  }
  clearCache() {
    this.notifications.cache.clearAll();
    this.preferences.cache.clearAll();
    this.preferences.scheduleCache.clearAll();
    this.subscriptions.cache.clearAll();
  }
  /**
   * @deprecated
   */
  changeSubscriber(options) {
    return __async(this, null, function* () {
      yield __privateGet(this, _session).initialize({
        applicationIdentifier: __privateGet(this, _session).applicationIdentifier || "",
        subscriberHash: options.subscriberHash,
        subscriber: options.subscriber,
        // Preserve existing context and contextHash
        context: __privateGet(this, _session).context,
        contextHash: __privateGet(this, _session).contextHash
      });
      this.clearCache();
      const disconnectResult = yield this.socket.disconnect();
      if (!disconnectResult.error) {
        yield this.socket.connect();
      }
    });
  }
  /**
   * @deprecated
   */
  changeContext(options) {
    return __async(this, null, function* () {
      const currentSubscriber = __privateGet(this, _session).subscriber;
      if (!currentSubscriber) {
        throw new Error("Cannot change context without an active subscriber");
      }
      yield __privateGet(this, _session).initialize({
        applicationIdentifier: __privateGet(this, _session).applicationIdentifier || "",
        // Preserve existing subscriber and subscriberHash
        subscriberHash: __privateGet(this, _session).subscriberHash,
        subscriber: currentSubscriber,
        context: options.context,
        contextHash: options.contextHash
      });
      this.clearCache();
      const disconnectResult = yield this.socket.disconnect();
      if (!disconnectResult.error) {
        yield this.socket.connect();
      }
    });
  }
};
_emitter12 = new WeakMap();
_session = new WeakMap();
_inboxService6 = new WeakMap();
_options2 = new WeakMap();

export { DEFAULT_API_VERSION, Novu, SubscriptionPreference, TopicSubscription, areSeveritiesEqual, areTagsEqual, checkNotificationDataFilter, checkNotificationMatchesFilter, checkNotificationTagFilter, isBrowser, isSameFilter };
