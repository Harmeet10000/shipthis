import { M as InboxService, O as NovuEventEmitter, Q as Session, R as Result, V as ScheduleCache, v as Schedule, X as UpdateScheduleArgs, Y as PreferencesCache, Z as ListPreferencesArgs, s as Preference, _ as BasePreferenceArgs, $ as InstancePreferenceArgs, a0 as ListNotificationsArgs, p as ListNotificationsResponse, o as InboxNotification, a as Notification, N as NotificationFilter, a1 as FilterCountArgs, a2 as FilterCountResponse, a3 as FiltersCountArgs, F as FiltersCountResponse, a4 as BaseArgs, a5 as InstanceArgs, a6 as SnoozeArgs, a7 as SubscriptionsCache, x as Subscriber, L as ListSubscriptionsArgs, a8 as Options, T as TopicSubscription, G as GetSubscriptionArgs, C as CreateSubscriptionArgs, f as BaseUpdateSubscriptionArgs, g as InstanceUpdateSubscriptionArgs, B as BaseDeleteSubscriptionArgs, I as InstanceDeleteSubscriptionArgs, c as SocketEventNames, a9 as EventNames, E as EventHandler, b as Events, aa as ContextValue, r as NovuOptions, l as Context } from './novu-event-emitter-BFZmnC3B.js';

declare class BaseModule {
    #private;
    _inboxService: InboxService;
    _emitter: NovuEventEmitter;
    constructor({ inboxServiceInstance, eventEmitterInstance, }: {
        inboxServiceInstance: InboxService;
        eventEmitterInstance: NovuEventEmitter;
    });
    protected onSessionSuccess(_: Session): void;
    protected onSessionError(_: unknown): void;
    callWithSession<T>(fn: () => Result<T>): Result<T>;
}

declare class PreferenceSchedule extends BaseModule {
    #private;
    readonly cache: ScheduleCache;
    constructor({ cache, useCache, inboxServiceInstance, eventEmitterInstance, }: {
        cache: ScheduleCache;
        useCache: boolean;
        inboxServiceInstance: InboxService;
        eventEmitterInstance: NovuEventEmitter;
    });
    get(): Result<Schedule>;
    update(args: UpdateScheduleArgs): Result<Schedule>;
}

declare class Preferences extends BaseModule {
    #private;
    readonly cache: PreferencesCache;
    readonly scheduleCache: ScheduleCache;
    readonly schedule: PreferenceSchedule;
    constructor({ useCache, inboxServiceInstance, eventEmitterInstance, }: {
        useCache: boolean;
        inboxServiceInstance: InboxService;
        eventEmitterInstance: NovuEventEmitter;
    });
    list(args?: ListPreferencesArgs): Result<Preference[]>;
    update(args: BasePreferenceArgs): Result<Preference>;
    update(args: InstancePreferenceArgs): Result<Preference>;
    bulkUpdate(args: Array<BasePreferenceArgs>): Result<Preference[]>;
    bulkUpdate(args: Array<InstancePreferenceArgs>): Result<Preference[]>;
}

declare class NotificationsCache {
    #private;
    constructor({ emitter, inboxService }: {
        emitter: NovuEventEmitter;
        inboxService: InboxService;
    });
    private updateNotification;
    private removeNotification;
    private handleNotificationEvent;
    private getAggregated;
    get(args: ListNotificationsArgs): ListNotificationsResponse | undefined;
    has(args: ListNotificationsArgs): boolean;
    set(args: ListNotificationsArgs, data: ListNotificationsResponse): void;
    unshift(args: ListNotificationsArgs, notification: InboxNotification): void;
    update(args: ListNotificationsArgs, data: ListNotificationsResponse): void;
    getAll(args: ListNotificationsArgs): ListNotificationsResponse | undefined;
    /**
     * Get unique notifications based on specified filter fields.
     * The same tags and data can be applied to multiple filters which means that the same notification can be duplicated.
     */
    getUniqueNotifications({ tags, read, data, }: Pick<ListNotificationsArgs, 'tags' | 'read' | 'data'>): Array<Notification>;
    clear(filter: NotificationFilter): void;
    clearAll(): void;
}

declare class Notifications extends BaseModule {
    #private;
    readonly cache: NotificationsCache;
    constructor({ useCache, inboxServiceInstance, eventEmitterInstance, }: {
        useCache: boolean;
        inboxServiceInstance: InboxService;
        eventEmitterInstance: NovuEventEmitter;
    });
    list({ limit, ...restOptions }?: ListNotificationsArgs): Result<ListNotificationsResponse>;
    count(args?: FilterCountArgs): Result<FilterCountResponse>;
    count(args?: FiltersCountArgs): Result<FiltersCountResponse>;
    read(args: BaseArgs): Result<Notification>;
    read(args: InstanceArgs): Result<Notification>;
    unread(args: BaseArgs): Result<Notification>;
    unread(args: InstanceArgs): Result<Notification>;
    seen(args: BaseArgs): Result<Notification>;
    seen(args: InstanceArgs): Result<Notification>;
    archive(args: BaseArgs): Result<Notification>;
    archive(args: InstanceArgs): Result<Notification>;
    unarchive(args: BaseArgs): Result<Notification>;
    unarchive(args: InstanceArgs): Result<Notification>;
    delete(args: BaseArgs): Result<void>;
    delete(args: InstanceArgs): Result<void>;
    snooze(args: SnoozeArgs): Result<Notification>;
    unsnooze(args: BaseArgs): Result<Notification>;
    unsnooze(args: InstanceArgs): Result<Notification>;
    completePrimary(args: BaseArgs): Result<Notification>;
    completePrimary(args: InstanceArgs): Result<Notification>;
    completeSecondary(args: BaseArgs): Result<Notification>;
    completeSecondary(args: InstanceArgs): Result<Notification>;
    revertPrimary(args: BaseArgs): Result<Notification>;
    revertPrimary(args: InstanceArgs): Result<Notification>;
    revertSecondary(args: BaseArgs): Result<Notification>;
    revertSecondary(args: InstanceArgs): Result<Notification>;
    readAll({ tags, data, }?: {
        tags?: NotificationFilter['tags'];
        data?: Record<string, unknown>;
    }): Result<void>;
    seenAll(args?: {
        notificationIds: string[];
    } | {
        tags?: NotificationFilter['tags'];
        data?: Record<string, unknown>;
    } | {}): Result<void>;
    archiveAll({ tags, data, }?: {
        tags?: NotificationFilter['tags'];
        data?: Record<string, unknown>;
    }): Result<void>;
    archiveAllRead({ tags, data }?: {
        tags?: string[];
        data?: Record<string, unknown>;
    }): Result<void>;
    deleteAll({ tags, data, }?: {
        tags?: NotificationFilter['tags'];
        data?: Record<string, unknown>;
    }): Result<void>;
    clearCache({ filter }?: {
        filter?: NotificationFilter;
    }): void;
    triggerHelloWorldEvent(): Promise<any>;
}

declare class Subscriptions extends BaseModule {
    #private;
    readonly cache: SubscriptionsCache;
    constructor({ useCache, inboxServiceInstance, eventEmitterInstance, subscriber, contextKey, }: {
        useCache: boolean;
        inboxServiceInstance: InboxService;
        eventEmitterInstance: NovuEventEmitter;
        subscriber: Subscriber;
        contextKey: string;
    });
    list(args: ListSubscriptionsArgs, options?: Options): Result<TopicSubscription[]>;
    get(args: GetSubscriptionArgs, options?: Options): Result<TopicSubscription | null>;
    create(args: CreateSubscriptionArgs): Result<TopicSubscription>;
    update(args: BaseUpdateSubscriptionArgs): Result<TopicSubscription>;
    update(args: InstanceUpdateSubscriptionArgs): Result<TopicSubscription>;
    delete(args: BaseDeleteSubscriptionArgs): Result<void>;
    delete(args: InstanceDeleteSubscriptionArgs): Result<void>;
}

interface BaseSocketInterface {
    isSocketEvent(eventName: string): eventName is SocketEventNames;
    connect(): Result<void>;
    disconnect(): Result<void>;
}

declare class Novu implements Pick<NovuEventEmitter, 'on'> {
    #private;
    readonly notifications: Notifications;
    readonly preferences: Preferences;
    readonly subscriptions: Subscriptions;
    readonly socket: BaseSocketInterface;
    on: <Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => () => void;
    /**
     * @deprecated
     * Use the cleanup function returned by the "on" method instead.
     */
    off: <Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => void;
    get applicationIdentifier(): string | undefined;
    get subscriberId(): string | undefined;
    get context(): Partial<Record<string, ContextValue>> | undefined;
    get options(): NovuOptions;
    get contextKey(): string;
    constructor(options: NovuOptions);
    private clearCache;
    /**
     * @deprecated
     */
    changeSubscriber(options: {
        subscriber: Subscriber;
        subscriberHash?: string;
    }): Promise<void>;
    /**
     * @deprecated
     */
    changeContext(options: {
        context: Context;
        contextHash?: string;
    }): Promise<void>;
}

export { Novu as N };
